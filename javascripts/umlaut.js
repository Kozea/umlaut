// Generated by CoffeeScript 1.6.3
var Actor, Aggregation, Arrow, Assign, Association, Attribute, Attributes, BRACES, Base, Battery, BlackArrow, Brace, Case, Class, ClassDiagram, Comment, Composition, Container, DELIMITERS, Database, Decision, Delay, Delimiter, Diagram, Diamond, Diode, Document, DotDiagram, Edge, Electric, ElectricDiagram, Element, Ellipsis, Flow, FlowChart, Graph, Group, HardDisk, IO, Id, Inheritance, InternalStorage, KEYWORDS, Keyword, Link, Lozenge, ManualInput, Marker, Mouse, NPNTransistor, Node, Note, Number, OPERATORS, Operator, PANIC_THRESHOLD, PNPTransistor, Preparation, Process, QuotedId, RE_ALPHA, RE_ALPHADIGIT, RE_DIGIT, RE_SPACE, Rect, Resistor, Statement, SubGraph, SubProcess, Svg, System, Terminator, Token, Transistor, UseCase, Void, WhiteArrow, WhiteDiamond, Wire, anchor_link_drag, angle_to_cardinal, arrow, atan2, bare_link, blackarrow, blackdiamond, cardinal, cardinal_to_direction, commands, dist, dot, dot_lex, dot_tokenize, dotted, edit, ellipsis, enter_link, enter_node, generate_url, history_pop, init_commands, link_drag, list_diagrams, load, lozenge, mod2pi, mouse_anchor, mouse_link, mouse_node, mouse_xy, move_drag, node_add, note, nsweo_resize_drag, order, pi, rectangle, rotate, save, tick_link, tick_node, timestamp, to_deg, to_rad, to_svg_angle, uml_elements, uml_links, update_link, update_node, whitearrow, whitediamond, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref27, _ref28, _ref29, _ref3, _ref30, _ref31, _ref32, _ref33, _ref34, _ref35, _ref36, _ref37, _ref38, _ref39, _ref4, _ref40, _ref41, _ref42, _ref43, _ref44, _ref45, _ref46, _ref47, _ref48, _ref49, _ref5, _ref50, _ref51, _ref52, _ref53, _ref54, _ref6, _ref7, _ref8, _ref9,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  _this = this,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

pi = Math.PI;

to_deg = function(a) {
  return 180 * a / pi;
};

to_rad = function(a) {
  return pi * a / 180;
};

dist = function(o, t) {
  return Math.sqrt(Math.pow(t.x - o.x, 2) + Math.pow(t.y - o.y, 2));
};

rotate = function(pos, a) {
  return {
    x: pos.x * Math.cos(a) - pos.y * Math.sin(a),
    y: pos.x * Math.sin(a) + pos.y * Math.cos(a)
  };
};

mod2pi = function(a) {
  return ((a % (2 * pi)) + 2 * pi) % (2 * pi);
};

atan2 = function(y, x) {
  return mod2pi(Math.atan2(y, x));
};

to_svg_angle = function(a) {
  return to_deg(mod2pi(a));
};

cardinal = {
  N: 3 * pi / 2,
  S: pi / 2,
  W: pi,
  E: 0
};

angle_to_cardinal = function(a) {
  if ((pi / 4 < a && a <= 3 * pi / 4)) {
    return 'S';
  }
  if ((3 * pi / 4 < a && a <= 5 * pi / 4)) {
    return 'W';
  }
  if ((5 * pi / 4 < a && a <= 7 * pi / 4)) {
    return 'N';
  }
  return 'E';
};

cardinal_to_direction = function(c) {
  switch (c) {
    case 'N':
      return {
        x: 0,
        y: -1
      };
    case 'S':
      return {
        x: 0,
        y: 1
      };
    case 'W':
      return {
        x: -1,
        y: 0
      };
    case 'E':
      return {
        x: 1,
        y: 0
      };
    case 'SE':
      return {
        x: 1,
        y: 1
      };
    case 'SW':
      return {
        x: -1,
        y: 1
      };
    case 'NW':
      return {
        x: -1,
        y: -1
      };
    case 'NE':
      return {
        x: 1,
        y: -1
      };
  }
};

timestamp = function() {
  return new Date().getTime();
};

Base = (function() {
  function Base() {
    this.cls = this.constructor;
  }

  Base.prototype["super"] = function(fun, cls, args) {
    if (cls == null) {
      cls = null;
    }
    if (args == null) {
      args = [];
    }
    return (cls || this.cls).__super__[fun].apply(this, args);
  };

  return Base;

})();

Element = (function(_super) {
  __extends(Element, _super);

  Element.handle_size = 10;

  Element.resizeable = true;

  Element.rotationable = false;

  Element.fill = 'bg';

  Element.stroke = 'fg';

  function Element(x, y, text, fixed) {
    var _this = this;
    this.x = x;
    this.y = y;
    this.text = text;
    this.fixed = fixed != null ? fixed : false;
    Element.__super__.constructor.apply(this, arguments);
    this.ts = timestamp();
    this.margin = {
      x: 10,
      y: 5
    };
    this._width = null;
    this._height = null;
    this._rotation = 0;
    this.anchors = {};
    this.anchors[cardinal.N] = function() {
      return {
        x: _this.x,
        y: _this.y - _this.height() / 2
      };
    };
    this.anchors[cardinal.S] = function() {
      return {
        x: _this.x,
        y: _this.y + _this.height() / 2
      };
    };
    this.anchors[cardinal.E] = function() {
      return {
        x: _this.x + _this.width() / 2,
        y: _this.y
      };
    };
    this.anchors[cardinal.W] = function() {
      return {
        x: _this.x - _this.width() / 2,
        y: _this.y
      };
    };
    this.handles = {
      NE: function() {
        return {
          x: _this.width() / 2,
          y: -_this.height() / 2
        };
      },
      NW: function() {
        return {
          x: -_this.width() / 2,
          y: -_this.height() / 2
        };
      },
      SW: function() {
        return {
          x: -_this.width() / 2,
          y: _this.height() / 2
        };
      },
      SE: function() {
        return {
          x: _this.width() / 2,
          y: _this.height() / 2
        };
      },
      O: function() {
        return {
          x: 0,
          y: -_this.height() / 2
        };
      }
    };
  }

  Element.prototype.rotate = function(pos, direct) {
    var ang, normed;
    if (direct == null) {
      direct = true;
    }
    if (void 0 === pos.x || void 0 === pos.y) {
      return null;
    }
    ang = direct ? this._rotation : 2 * pi - this._rotation;
    normed = {
      x: pos.x - this.x,
      y: pos.y - this.y
    };
    normed = rotate(normed, ang);
    normed.x += this.x;
    normed.y += this.y;
    return normed;
  };

  Element.prototype.anchor_list = function() {
    return [cardinal.N, cardinal.S, cardinal.W, cardinal.E];
  };

  Element.prototype.handle_list = function() {
    var l;
    l = [];
    if (this.cls.resizeable) {
      l = l.concat(['NW', 'NE', 'SW', 'SE']);
    }
    if (this.cls.rotationable) {
      l.push('O');
    }
    return l;
  };

  Element.prototype.pos = function() {
    return this.rotate({
      x: this.x,
      y: this.y
    });
  };

  Element.prototype.set_txt_bbox = function(bbox) {
    return this._txt_bbox = bbox;
  };

  Element.prototype.txt_width = function() {
    return this._txt_bbox.width + 2 * this.margin.x;
  };

  Element.prototype.txt_height = function() {
    return this._txt_bbox.height + 2 * this.margin.y;
  };

  Element.prototype.txt_x = function() {
    return 0;
  };

  Element.prototype.txt_y = function() {
    return -this._txt_bbox.height / 2;
  };

  Element.prototype.width = function(w) {
    if (w == null) {
      w = null;
    }
    if (w !== null) {
      this._width = w;
    }
    return Math.max(this._width || 0, this.txt_width());
  };

  Element.prototype.height = function(h) {
    if (h == null) {
      h = null;
    }
    if (h !== null) {
      this._height = h;
    }
    return Math.max(this._height || 0, this.txt_height());
  };

  Element.prototype.direction = function(x, y) {
    var anchor, diff, min_anchor, min_diff, origin, pos, target, _ref;
    target = atan2(y - this.y, x - this.x);
    min_diff = Infinity;
    _ref = this.anchors;
    for (anchor in _ref) {
      pos = _ref[anchor];
      origin = +anchor + this._rotation;
      diff = Math.min(Math.abs(target - origin) % (2 * pi), Math.abs(target - origin - 2 * pi) % (2 * pi));
      if (diff < min_diff) {
        min_diff = diff;
        min_anchor = anchor;
      }
    }
    return +min_anchor;
  };

  Element.prototype["in"] = function(rect) {
    var _ref, _ref1;
    return (rect.x < (_ref = this.x) && _ref < rect.x + rect.width) && (rect.y < (_ref1 = this.y) && _ref1 < rect.y + rect.height);
  };

  Element.prototype.contains = function() {
    return false;
  };

  Element.prototype.objectify = function() {
    return {
      name: this.constructor.name,
      x: this.x,
      y: this.y,
      width: this._width,
      height: this._height,
      rotation: this._rotation,
      text: this.text,
      fixed: this.fixed
    };
  };

  return Element;

})(Base);

Mouse = (function(_super) {
  __extends(Mouse, _super);

  Mouse.prototype.width = function() {
    return 1;
  };

  Mouse.prototype.height = function() {
    return 1;
  };

  Mouse.prototype.weight = 1;

  function Mouse() {
    var i, _i;
    Mouse.__super__.constructor.apply(this, arguments);
    this.lasts = [];
    for (i = _i = 0; _i <= 5; i = ++_i) {
      this.lasts.push({
        x: 0,
        y: 0
      });
    }
  }

  Mouse.prototype.dynamic_rotation = function() {
    return this._rotation = atan2(this.lasts.map(function(e) {
      return e.y;
    }).reduce((function(e, l) {
      return e + l;
    }), 0), this.lasts.map(function(e) {
      return e.x;
    }).reduce((function(e, l) {
      return e + l;
    }), 0));
  };

  return Mouse;

})(Element);

Marker = (function(_super) {
  __extends(Marker, _super);

  function Marker() {
    Marker.__super__.constructor.apply(this, arguments);
    this.id = this.constructor.name;
  }

  return Marker;

})(Base);

Void = (function(_super) {
  __extends(Void, _super);

  function Void() {
    _ref = Void.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Void.prototype.path = function() {
    return 'M 0 0';
  };

  return Void;

})(Marker);

Arrow = (function(_super) {
  __extends(Arrow, _super);

  function Arrow() {
    _ref1 = Arrow.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  Arrow.prototype.path = function() {
    return 'M 10 0 L 20 5 L 10 10';
  };

  return Arrow;

})(Marker);

BlackArrow = (function(_super) {
  __extends(BlackArrow, _super);

  function BlackArrow() {
    _ref2 = BlackArrow.__super__.constructor.apply(this, arguments);
    return _ref2;
  }

  BlackArrow.prototype.path = function() {
    return "" + (BlackArrow.__super__.path.call(this)) + " z";
  };

  return BlackArrow;

})(Arrow);

Link = (function(_super) {
  __extends(Link, _super);

  Link.marker = new Void();

  Link.type = 'full';

  Link.prototype.text_margin = 10;

  function Link(source, target, text) {
    this.source = source;
    this.target = target;
    Link.__super__.constructor.apply(this, arguments);
    this.a1 = this.a2 = 0;
    this.text = {
      source: (text != null ? text.source : void 0) || '',
      target: (text != null ? text.target : void 0) || ''
    };
  }

  Link.prototype.objectify = function() {
    return {
      name: this.constructor.name,
      source: diagram.nodes().indexOf(this.source),
      target: diagram.nodes().indexOf(this.target),
      source_anchor: this.source_anchor,
      target_anchor: this.target_anchor,
      text: this.text
    };
  };

  Link.prototype.nearest = function(pos) {
    if (dist(pos, this.a1) < dist(pos, this.a2)) {
      return this.source;
    } else {
      return this.target;
    }
  };

  Link.prototype.path = function() {
    var c1, c2, d, d1, d2, dx, dy, horizontal_1, horizontal_2, m, mid, path;
    c1 = this.source.pos();
    c2 = this.target.pos();
    if ((null === c1 || null === c2) || (void 0 === c1.x || void 0 === c1.y || void 0 === c2.x || void 0 === c2.y)) {
      return 'M 0 0';
    }
    d1 = +(this.source_anchor != null ? this.source_anchor : this.source.direction(c2.x, c2.y));
    this.a1 = this.source.rotate(this.source.anchors[d1]());
    d2 = +(this.target_anchor != null ? this.target_anchor : this.target.direction(this.a1.x, this.a1.y));
    this.a2 = this.target.rotate(this.target.anchors[d2]());
    this.o1 = d1 + this.source._rotation;
    this.o2 = d2 + this.target._rotation;
    path = "M " + this.a1.x + " " + this.a1.y;
    horizontal_1 = Math.abs(d1 % pi) < pi / 4;
    horizontal_2 = Math.abs(d2 % pi) < pi / 4;
    if (diagram.linkstyle === 'demicurve') {
      path = "" + path + " C";
      m = {
        x: .5 * (this.a1.x + this.a2.x),
        y: .5 * (this.a1.y + this.a2.y)
      };
      if (horizontal_1) {
        path = "" + path + " " + m.x + " " + this.a1.y;
      } else {
        path = "" + path + " " + this.a1.x + " " + m.y;
      }
      if (horizontal_2) {
        path = "" + path + " " + m.x + " " + this.a2.y;
      } else {
        path = "" + path + " " + this.a2.x + " " + m.y;
      }
    } else if (diagram.linkstyle === 'diagonal') {
      path = "" + path + " L";
    } else if (diagram.linkstyle === 'rectangular') {
      path = "" + path + " L";
      if (!horizontal_1 && horizontal_2) {
        path = "" + path + " " + this.a1.x + " " + this.a2.y + " L";
      } else if (horizontal_1 && !horizontal_2) {
        path = "" + path + " " + this.a2.x + " " + this.a1.y + " L";
      } else if (horizontal_1 && horizontal_2) {
        mid = this.a1.x + .5 * (this.a2.x - this.a1.x);
        path = "" + path + " " + mid + " " + this.a1.y + " L " + mid + " " + this.a2.y + " L";
      } else if (!horizontal_1 && !horizontal_2) {
        mid = this.a1.y + .5 * (this.a2.y - this.a1.y);
        path = "" + path + " " + this.a1.x + " " + mid + " L " + this.a2.x + " " + mid + " L";
      }
    } else if (diagram.linkstyle === 'curve') {
      path = "" + path + " C";
      d = dist(this.a1, this.a2) / 2;
      dx = Math.cos(this.o1) * d;
      dy = Math.sin(this.o1) * d;
      path = "" + path + " " + (this.a1.x + dx) + " " + (this.a1.y + dy);
      dx = Math.cos(this.o2) * d;
      dy = Math.sin(this.o2) * d;
      path = "" + path + " " + (this.a2.x + dx) + " " + (this.a2.y + dy);
    }
    return "" + path + " " + this.a2.x + " " + this.a2.y;
  };

  return Link;

})(Base);

Diagram = (function(_super) {
  __extends(Diagram, _super);

  Diagram.diagrams = {};

  function Diagram() {
    Diagram.__super__.constructor.apply(this, arguments);
    this.title = 'Untitled ' + this.label;
    this.linkstyle = 'rectangular';
    this.zoom = {
      scale: 1,
      translate: [0, 0]
    };
    this.elements = [];
    this.links = [];
    this.groups = [];
    this.snap = {
      x: 25,
      y: 25,
      a: 22.5
    };
    this.types = {};
    this.selection = [];
    this.linking = [];
    this.last_types = {
      link: null,
      element: null,
      group: null
    };
    this.mouse = new Mouse(0, 0, '');
    this.dragging = false;
    this.groupping = false;
  }

  Diagram.prototype.start_force = function() {
    var _this = this;
    this.force = d3.layout.force().gravity(.2).linkDistance(200).charge(function(node) {
      return -node.width() * node.height();
    }).size([svg.width, svg.height]);
    this.force.on('tick', function() {
      return svg.tick();
    });
    svg.sync();
    return this.force.start();
  };

  Diagram.prototype.markers = function() {
    var key, markers, type, val, _i, _len, _ref3, _results;
    markers = {};
    _ref3 = this.types.links;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      type = _ref3[_i];
      markers[type.marker.id] = type.marker;
    }
    _results = [];
    for (key in markers) {
      val = markers[key];
      _results.push(val);
    }
    return _results;
  };

  Diagram.prototype.group = function(name) {
    var grp, _i, _len, _ref3;
    _ref3 = this.types.groups;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      grp = _ref3[_i];
      if (grp.name === name) {
        return grp;
      }
    }
  };

  Diagram.prototype.element = function(name) {
    var elt, _i, _len, _ref3;
    _ref3 = this.types.elements;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      elt = _ref3[_i];
      if (elt.name === name) {
        return elt;
      }
    }
  };

  Diagram.prototype.link = function(name) {
    var lnk, _i, _len, _ref3;
    _ref3 = this.types.links;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      lnk = _ref3[_i];
      if (lnk.name === name) {
        return lnk;
      }
    }
  };

  Diagram.prototype.nodes = function() {
    return this.elements.concat(this.groups);
  };

  Diagram.prototype.objectify = function() {
    return {
      name: this.constructor.name,
      title: this.title,
      linkstyle: this.linkstyle,
      zoom: this.zoom,
      elements: this.elements.map(function(elt) {
        return elt.objectify();
      }),
      groups: this.groups.map(function(grp) {
        return grp.objectify();
      }),
      links: this.links.map(function(lnk) {
        return lnk.objectify();
      }),
      force: this.force ? true : false
    };
  };

  Diagram.prototype.hash = function() {
    return btoa(unescape(encodeURIComponent(JSON.stringify(this.objectify()))));
  };

  Diagram.prototype.loads = function(obj) {
    var element, element_type, elt, group, group_type, grp, link, link_type, lnk, _i, _j, _k, _len, _len1, _len2, _ref3, _ref4, _ref5;
    if (obj.title) {
      this.title = obj.title;
    }
    if (obj.linkstyle) {
      this.linkstyle = obj.linkstyle;
    }
    if (obj.zoom) {
      this.zoom = obj.zoom;
    }
    _ref3 = obj.groups || [];
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      grp = _ref3[_i];
      group_type = this.group(grp.name);
      group = new group_type(grp.x, grp.y, grp.text, false);
      group._width = grp.width || null;
      group._height = grp.height || null;
      group._rotation = grp.rotation || 0;
      this.groups.push(group);
    }
    _ref4 = obj.elements;
    for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
      elt = _ref4[_j];
      element_type = this.element(elt.name);
      element = new element_type(elt.x, elt.y, elt.text, false);
      element._width = elt.width || null;
      element._height = elt.height || null;
      element._rotation = elt.rotation || 0;
      this.elements.push(element);
    }
    _ref5 = obj.links;
    for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
      lnk = _ref5[_k];
      link_type = this.link(lnk.name);
      link = new link_type(this.nodes()[lnk.source], this.nodes()[lnk.target], lnk.text);
      link.source_anchor = lnk.source_anchor;
      link.target_anchor = lnk.target_anchor;
      this.links.push(link);
    }
    if (obj.force) {
      return this.start_force();
    }
  };

  return Diagram;

})(Base);

Rect = (function(_super) {
  __extends(Rect, _super);

  function Rect() {
    _ref3 = Rect.__super__.constructor.apply(this, arguments);
    return _ref3;
  }

  Rect.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " " + (-h2) + "         L " + w2 + " " + (-h2) + "         L " + w2 + " " + h2 + "         L " + (-w2) + " " + h2 + "         z";
  };

  return Rect;

})(Element);

Ellipsis = (function(_super) {
  __extends(Ellipsis, _super);

  function Ellipsis() {
    _ref4 = Ellipsis.__super__.constructor.apply(this, arguments);
    return _ref4;
  }

  Ellipsis.prototype.txt_width = function() {
    return 2 * Ellipsis.__super__.txt_width.call(this) / Math.sqrt(2);
  };

  Ellipsis.prototype.txt_height = function() {
    return 2 * Ellipsis.__super__.txt_height.call(this) / Math.sqrt(2);
  };

  Ellipsis.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " 0         A " + w2 + " " + h2 + " 0 1 1 " + w2 + " 0         A " + w2 + " " + h2 + " 0 1 1 " + (-w2) + " 0        ";
  };

  return Ellipsis;

})(Element);

Note = (function(_super) {
  __extends(Note, _super);

  function Note() {
    _ref5 = Note.__super__.constructor.apply(this, arguments);
    return _ref5;
  }

  Note.prototype.shift = 15;

  Note.prototype.txt_width = function() {
    return Note.__super__.txt_width.call(this) + this.shift;
  };

  Note.prototype.txt_x = function() {
    return Note.__super__.txt_x.call(this) - this.shift / 2;
  };

  Note.prototype.txt_y = function() {
    return Note.__super__.txt_y.call(this);
  };

  Note.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " " + (-h2) + "         L " + (w2 - this.shift) + " " + (-h2) + "         L " + w2 + " " + (-h2 + this.shift) + "         L " + w2 + " " + h2 + "         L " + (-w2) + " " + h2 + "         L " + (-w2) + " " + (-h2 + this.shift) + "         z         M " + w2 + " " + (-h2 + this.shift) + "         L " + (w2 - this.shift) + " " + (-h2 + this.shift) + "         L " + (w2 - this.shift) + " " + (-h2) + "        ";
  };

  return Note;

})(Element);

Lozenge = (function(_super) {
  __extends(Lozenge, _super);

  function Lozenge() {
    _ref6 = Lozenge.__super__.constructor.apply(this, arguments);
    return _ref6;
  }

  Lozenge.prototype.txt_width = function() {
    var ow;
    ow = Lozenge.__super__.txt_width.call(this);
    return ow + Math.sqrt(ow * this["super"]('txt_height', Lozenge));
  };

  Lozenge.prototype.txt_height = function() {
    var oh;
    oh = Lozenge.__super__.txt_height.call(this);
    return oh + Math.sqrt(oh * this["super"]('txt_width', Lozenge));
  };

  Lozenge.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " 0         L 0 " + (-h2) + "         L " + w2 + " 0         L 0 " + h2 + "         z";
  };

  return Lozenge;

})(Element);

WhiteArrow = (function(_super) {
  __extends(WhiteArrow, _super);

  function WhiteArrow() {
    _ref7 = WhiteArrow.__super__.constructor.apply(this, arguments);
    return _ref7;
  }

  return WhiteArrow;

})(BlackArrow);

Diamond = (function(_super) {
  __extends(Diamond, _super);

  function Diamond() {
    _ref8 = Diamond.__super__.constructor.apply(this, arguments);
    return _ref8;
  }

  Diamond.prototype.path = function() {
    return 'M 0 5 L 10 0 L 20 5 L 10 10 z';
  };

  return Diamond;

})(Marker);

WhiteDiamond = (function(_super) {
  __extends(WhiteDiamond, _super);

  function WhiteDiamond() {
    _ref9 = WhiteDiamond.__super__.constructor.apply(this, arguments);
    return _ref9;
  }

  return WhiteDiamond;

})(Diamond);

Association = (function(_super) {
  __extends(Association, _super);

  function Association() {
    _ref10 = Association.__super__.constructor.apply(this, arguments);
    return _ref10;
  }

  Association.marker = new BlackArrow();

  return Association;

})(Link);

Inheritance = (function(_super) {
  __extends(Inheritance, _super);

  function Inheritance() {
    _ref11 = Inheritance.__super__.constructor.apply(this, arguments);
    return _ref11;
  }

  Inheritance.marker = new WhiteArrow();

  return Inheritance;

})(Link);

Composition = (function(_super) {
  __extends(Composition, _super);

  function Composition() {
    _ref12 = Composition.__super__.constructor.apply(this, arguments);
    return _ref12;
  }

  Composition.marker = new Diamond();

  return Composition;

})(Link);

Comment = (function(_super) {
  __extends(Comment, _super);

  function Comment() {
    _ref13 = Comment.__super__.constructor.apply(this, arguments);
    return _ref13;
  }

  Comment.marker = new Arrow();

  Comment.type = 'dashed';

  return Comment;

})(Link);

Aggregation = (function(_super) {
  __extends(Aggregation, _super);

  function Aggregation() {
    _ref14 = Aggregation.__super__.constructor.apply(this, arguments);
    return _ref14;
  }

  Aggregation.marker = new WhiteDiamond();

  return Aggregation;

})(Link);

uml_links = [Association, Inheritance, Aggregation, Composition, Comment];

uml_elements = [Note];

Group = (function(_super) {
  __extends(Group, _super);

  function Group() {
    _ref15 = Group.__super__.constructor.apply(this, arguments);
    return _ref15;
  }

  Group.prototype.contains = function(elt) {
    var h2, w2, _ref16, _ref17;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return (this.x - w2 < (_ref16 = elt.x) && _ref16 < this.x + w2) && (this.y - h2 < (_ref17 = elt.y) && _ref17 < this.y + h2);
  };

  Group.prototype.txt_y = function() {
    return -this.height() / 2 + this.margin.y;
  };

  Group.prototype.path = function() {
    var h2, h2l, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    h2l = -h2 + this.txt_height() + this.margin.y;
    return "M " + (-w2) + " " + (-h2) + "         L " + w2 + " " + (-h2) + "         L " + w2 + " " + h2l + "         L " + (-w2) + " " + h2l + "         z         M " + w2 + " " + h2l + "         L " + w2 + " " + h2 + "         L " + (-w2) + " " + h2 + "         L " + (-w2) + " " + h2l + "        ";
  };

  return Group;

})(Element);

rectangle = (function(_super) {
  __extends(rectangle, _super);

  function rectangle() {
    _ref16 = rectangle.__super__.constructor.apply(this, arguments);
    return _ref16;
  }

  rectangle.rotationable = true;

  return rectangle;

})(Rect);

ellipsis = (function(_super) {
  __extends(ellipsis, _super);

  function ellipsis() {
    _ref17 = ellipsis.__super__.constructor.apply(this, arguments);
    return _ref17;
  }

  ellipsis.rotationable = true;

  return ellipsis;

})(Ellipsis);

lozenge = (function(_super) {
  __extends(lozenge, _super);

  function lozenge() {
    _ref18 = lozenge.__super__.constructor.apply(this, arguments);
    return _ref18;
  }

  lozenge.rotationable = true;

  return lozenge;

})(Lozenge);

note = (function(_super) {
  __extends(note, _super);

  function note() {
    _ref19 = note.__super__.constructor.apply(this, arguments);
    return _ref19;
  }

  note.rotationable = true;

  return note;

})(Note);

bare_link = (function(_super) {
  __extends(bare_link, _super);

  function bare_link() {
    _ref20 = bare_link.__super__.constructor.apply(this, arguments);
    return _ref20;
  }

  return bare_link;

})(Link);

arrow = (function(_super) {
  __extends(arrow, _super);

  function arrow() {
    _ref21 = arrow.__super__.constructor.apply(this, arguments);
    return _ref21;
  }

  arrow.marker = new Arrow();

  return arrow;

})(Link);

blackarrow = (function(_super) {
  __extends(blackarrow, _super);

  function blackarrow() {
    _ref22 = blackarrow.__super__.constructor.apply(this, arguments);
    return _ref22;
  }

  blackarrow.marker = new BlackArrow();

  return blackarrow;

})(Link);

whitearrow = (function(_super) {
  __extends(whitearrow, _super);

  function whitearrow() {
    _ref23 = whitearrow.__super__.constructor.apply(this, arguments);
    return _ref23;
  }

  whitearrow.marker = new WhiteArrow();

  return whitearrow;

})(Link);

blackdiamond = (function(_super) {
  __extends(blackdiamond, _super);

  function blackdiamond() {
    _ref24 = blackdiamond.__super__.constructor.apply(this, arguments);
    return _ref24;
  }

  blackdiamond.marker = new Diamond();

  return blackdiamond;

})(Link);

whitediamond = (function(_super) {
  __extends(whitediamond, _super);

  function whitediamond() {
    _ref25 = whitediamond.__super__.constructor.apply(this, arguments);
    return _ref25;
  }

  whitediamond.marker = new WhiteDiamond();

  return whitediamond;

})(Link);

dotted = (function(_super) {
  __extends(dotted, _super);

  function dotted() {
    _ref26 = dotted.__super__.constructor.apply(this, arguments);
    return _ref26;
  }

  dotted.marker = new Arrow();

  dotted.type = 'dashed';

  return dotted;

})(Link);

DotDiagram = (function(_super) {
  __extends(DotDiagram, _super);

  DotDiagram.prototype.label = 'Dot diagram';

  function DotDiagram() {
    DotDiagram.__super__.constructor.apply(this, arguments);
    this.linkstyle = 'curve';
    this.types = {
      elements: [rectangle, ellipsis, lozenge, note],
      groups: [],
      links: [bare_link, arrow, blackarrow, whitearrow, blackdiamond, whitediamond, dotted]
    };
  }

  return DotDiagram;

})(Diagram);

Diagram.diagrams['DotDiagram'] = DotDiagram;

Process = (function(_super) {
  __extends(Process, _super);

  function Process() {
    _ref27 = Process.__super__.constructor.apply(this, arguments);
    return _ref27;
  }

  return Process;

})(Rect);

IO = (function(_super) {
  __extends(IO, _super);

  function IO() {
    var _this = this;
    IO.__super__.constructor.apply(this, arguments);
    this.anchors[cardinal.N] = function() {
      return {
        x: _this.x - _this.height() / 4,
        y: _this.y - _this.height() / 2
      };
    };
    this.anchors[cardinal.S] = function() {
      return {
        x: _this.x + _this.height() / 4,
        y: _this.y + _this.height() / 2
      };
    };
    this.anchors[cardinal.E] = function() {
      return {
        x: _this.x + _this.width() / 2 - _this.height() / 4,
        y: _this.y
      };
    };
    this.anchors[cardinal.W] = function() {
      return {
        x: _this.x - _this.width() / 2 + _this.height() / 4,
        y: _this.y
      };
    };
  }

  IO.prototype.txt_width = function() {
    return IO.__super__.txt_width.call(this) + this.height();
  };

  IO.prototype.path = function() {
    var h2, lw2, w2;
    w2 = (this.width() - this.height()) / 2;
    h2 = this.height() / 2;
    lw2 = this.width() / 2;
    return "M " + (-lw2) + " " + (-h2) + "         L " + w2 + " " + (-h2) + "         L " + lw2 + " " + h2 + "         L " + (-w2) + " " + h2 + "         z";
  };

  return IO;

})(Element);

Terminator = (function(_super) {
  __extends(Terminator, _super);

  function Terminator() {
    _ref28 = Terminator.__super__.constructor.apply(this, arguments);
    return _ref28;
  }

  Terminator.prototype.path = function() {
    var h2, shift, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    shift = Math.min(w2 / 2, h2 / 2);
    return "M " + (-w2 + shift) + " " + (-h2) + "         L " + (w2 - shift) + " " + (-h2) + "         Q " + w2 + " " + (-h2) + " " + w2 + " " + (-h2 + shift) + "         L " + w2 + " " + (h2 - shift) + "         Q " + w2 + " " + h2 + " " + (w2 - shift) + " " + h2 + "         L " + (-w2 + shift) + " " + h2 + "         Q " + (-w2) + " " + h2 + " " + (-w2) + " " + (h2 - shift) + "         L " + (-w2) + " " + (-h2 + shift) + "         Q " + (-w2) + " " + (-h2) + " " + (-w2 + shift) + " " + (-h2);
  };

  return Terminator;

})(Element);

Decision = (function(_super) {
  __extends(Decision, _super);

  function Decision() {
    Decision.__super__.constructor.apply(this, arguments);
    this.margin.x = 0;
    this.margin.y = 2;
  }

  return Decision;

})(Lozenge);

Delay = (function(_super) {
  __extends(Delay, _super);

  function Delay() {
    var _this = this;
    Delay.__super__.constructor.apply(this, arguments);
    this.anchors[cardinal.N] = function() {
      return {
        x: _this.x + _this.txt_x(),
        y: _this.y - _this.height() / 2
      };
    };
    this.anchors[cardinal.S] = function() {
      return {
        x: _this.x + _this.txt_x(),
        y: _this.y + _this.height() / 2
      };
    };
  }

  Delay.prototype.txt_x = function() {
    return Delay.__super__.txt_x.call(this) - this.height() / 4 + this.txt_height() / 6;
  };

  Delay.prototype.txt_width = function() {
    return Math.max(0, Delay.__super__.txt_width.call(this) - this.txt_height() / 3) + this.height() / 2;
  };

  Delay.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " " + (-h2) + "         L " + (w2 - h2) + " " + (-h2) + "         A " + h2 + " " + h2 + " 0 1 1 " + (w2 - h2) + " " + h2 + "         L " + (-w2) + " " + h2 + "         z";
  };

  return Delay;

})(Element);

SubProcess = (function(_super) {
  __extends(SubProcess, _super);

  function SubProcess() {
    _ref29 = SubProcess.__super__.constructor.apply(this, arguments);
    return _ref29;
  }

  SubProcess.prototype.shift = 1.2;

  SubProcess.prototype.txt_width = function() {
    return SubProcess.__super__.txt_width.call(this) * this.shift;
  };

  SubProcess.prototype.shift_width = function() {
    return this.width() * (this.shift - 1) / this.shift;
  };

  SubProcess.prototype.path = function() {
    var h2, lw2, w2;
    w2 = this.width() / 2;
    lw2 = w2 - this.shift_width() / 2;
    h2 = this.height() / 2;
    return "" + (SubProcess.__super__.path.call(this)) + "         M " + (-lw2) + " " + (-h2) + "         L " + (-lw2) + " " + h2 + "         M " + lw2 + " " + (-h2) + "         L " + lw2 + " " + h2 + "        ";
  };

  return SubProcess;

})(Process);

Document = (function(_super) {
  __extends(Document, _super);

  function Document() {
    _ref30 = Document.__super__.constructor.apply(this, arguments);
    return _ref30;
  }

  Document.prototype.txt_height = function() {
    return Document.__super__.txt_height.call(this) * 1.25;
  };

  Document.prototype.txt_y = function() {
    return Document.__super__.txt_y.call(this) - this.height() / 16;
  };

  Document.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " " + (-h2) + "         L " + w2 + " " + (-h2) + "         L " + w2 + " " + h2 + "         Q " + (w2 / 2) + " " + (h2 / 2) + " 0 " + h2 + "         T " + (-w2) + " " + h2 + "         z";
  };

  return Document;

})(Element);

Database = (function(_super) {
  __extends(Database, _super);

  function Database() {
    _ref31 = Database.__super__.constructor.apply(this, arguments);
    return _ref31;
  }

  Database.prototype.txt_y = function() {
    return Database.__super__.txt_y.call(this) + this.radius() / 2;
  };

  Database.prototype.txt_height = function() {
    return Database.__super__.txt_height.call(this) + 20;
  };

  Database.prototype.radius = function() {
    return Math.min((this.height() - this["super"]('txt_height')) / 4, this.width() / 3);
  };

  Database.prototype.path = function() {
    var h2, r, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    r = this.radius();
    return "M " + (-w2) + " " + (-h2 + r) + "         A " + w2 + " " + r + " 0 1 1 " + w2 + " " + (-h2 + r) + "         A " + w2 + " " + r + " 0 1 1 " + (-w2) + " " + (-h2 + r) + "         M " + w2 + " " + (-h2 + r) + "         L " + w2 + " " + (h2 - r) + "         A " + w2 + " " + r + " 0 1 1 " + (-w2) + " " + (h2 - r) + "         L " + (-w2) + " " + (-h2 + r);
  };

  return Database;

})(Element);

HardDisk = (function(_super) {
  __extends(HardDisk, _super);

  function HardDisk() {
    _ref32 = HardDisk.__super__.constructor.apply(this, arguments);
    return _ref32;
  }

  HardDisk.prototype.txt_x = function() {
    return HardDisk.__super__.txt_x.call(this) - this.radius() / 2;
  };

  HardDisk.prototype.txt_width = function() {
    return HardDisk.__super__.txt_width.call(this) + 20;
  };

  HardDisk.prototype.radius = function() {
    return Math.min((this.width() - this["super"]('txt_width')) / 4, this.height() / 3);
  };

  HardDisk.prototype.path = function() {
    var h2, r, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    r = this.radius();
    return "M " + (w2 - r) + " " + h2 + "         A " + r + " " + h2 + " 0 1 1 " + (w2 - r) + " " + (-h2) + "         A " + r + " " + h2 + " 0 1 1 " + (w2 - r) + " " + h2 + "         L " + (-w2 + r) + " " + h2 + "         A " + r + " " + h2 + " 0 1 1 " + (-w2 + r) + " " + (-h2) + "         L " + (w2 - r) + " " + (-h2) + "        ";
  };

  return HardDisk;

})(Element);

ManualInput = (function(_super) {
  __extends(ManualInput, _super);

  ManualInput.prototype.shift = 2;

  function ManualInput() {
    var _this = this;
    ManualInput.__super__.constructor.apply(this, arguments);
    this.anchors[cardinal.N] = function() {
      return {
        x: _this.x,
        y: _this.y - _this.shift_height() / 2
      };
    };
    this.anchors[cardinal.W] = function() {
      return {
        x: _this.x - _this.width() / 2,
        y: _this.y + _this.shift_height() / 2
      };
    };
  }

  ManualInput.prototype.shift_height = function() {
    return this.height() * (this.shift - 1) / this.shift;
  };

  ManualInput.prototype.txt_height = function() {
    return ManualInput.__super__.txt_height.call(this) * this.shift;
  };

  ManualInput.prototype.txt_y = function() {
    return ManualInput.__super__.txt_y.call(this) + this.shift_height() / 2;
  };

  ManualInput.prototype.path = function() {
    var h2, th2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    th2 = h2 - this.shift_height();
    return "M " + (-w2) + " " + (-th2) + "          L " + w2 + " " + (-h2) + "          L " + w2 + " " + h2 + "          L " + (-w2) + " " + h2 + "          z";
  };

  return ManualInput;

})(Element);

Preparation = (function(_super) {
  __extends(Preparation, _super);

  function Preparation() {
    _ref33 = Preparation.__super__.constructor.apply(this, arguments);
    return _ref33;
  }

  Preparation.prototype.shift = 1.25;

  Preparation.prototype.txt_width = function() {
    return Preparation.__super__.txt_width.call(this) * this.shift;
  };

  Preparation.prototype.shift_width = function() {
    return this.width() * (this.shift - 1) / this.shift;
  };

  Preparation.prototype.path = function() {
    var h2, lw2, w2;
    w2 = this.width() / 2;
    lw2 = w2 - this.shift_width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " 0         L " + (-lw2) + " " + (-h2) + "         L " + lw2 + " " + (-h2) + "         L " + w2 + " 0         L " + lw2 + " " + h2 + "         L " + (-lw2) + " " + h2 + "         z";
  };

  return Preparation;

})(Element);

InternalStorage = (function(_super) {
  __extends(InternalStorage, _super);

  function InternalStorage() {
    _ref34 = InternalStorage.__super__.constructor.apply(this, arguments);
    return _ref34;
  }

  InternalStorage.prototype.hshift = 1.5;

  InternalStorage.prototype.wshift = 1.1;

  InternalStorage.prototype.txt_x = function() {
    return InternalStorage.__super__.txt_x.call(this) + this.shift_width() / 2;
  };

  InternalStorage.prototype.txt_y = function() {
    return InternalStorage.__super__.txt_y.call(this) + this.shift_height() / 2;
  };

  InternalStorage.prototype.txt_width = function() {
    return InternalStorage.__super__.txt_width.call(this) * this.wshift;
  };

  InternalStorage.prototype.txt_height = function() {
    return InternalStorage.__super__.txt_height.call(this) * this.hshift;
  };

  InternalStorage.prototype.shift_width = function() {
    return this.width() * (this.wshift - 1) / this.wshift;
  };

  InternalStorage.prototype.shift_height = function() {
    return this.height() * (this.hshift - 1) / this.hshift;
  };

  InternalStorage.prototype.path = function() {
    var h2, lh2, lw2, w2;
    w2 = this.width() / 2;
    lw2 = w2 - this.shift_width();
    h2 = this.height() / 2;
    lh2 = h2 - this.shift_height();
    return "" + (InternalStorage.__super__.path.call(this)) + "         M " + (-lw2) + " " + (-h2) + "         L " + (-lw2) + " " + h2 + "         M " + (-w2) + " " + (-lh2) + "         L " + w2 + " " + (-lh2) + "        ";
  };

  return InternalStorage;

})(Process);

Flow = (function(_super) {
  __extends(Flow, _super);

  function Flow() {
    _ref35 = Flow.__super__.constructor.apply(this, arguments);
    return _ref35;
  }

  Flow.marker = new BlackArrow();

  return Flow;

})(Link);

Container = (function(_super) {
  __extends(Container, _super);

  function Container() {
    _ref36 = Container.__super__.constructor.apply(this, arguments);
    return _ref36;
  }

  return Container;

})(Group);

FlowChart = (function(_super) {
  __extends(FlowChart, _super);

  FlowChart.prototype.label = 'Flow Chart';

  function FlowChart() {
    FlowChart.__super__.constructor.call(this);
    this.types = {
      elements: [Process, IO, Terminator, Decision, Delay, SubProcess, Document, Database, HardDisk, ManualInput, Preparation, InternalStorage],
      groups: [Container],
      links: [Flow]
    };
  }

  return FlowChart;

})(Diagram);

Diagram.diagrams['FlowChart'] = FlowChart;

Case = (function(_super) {
  __extends(Case, _super);

  function Case() {
    _ref37 = Case.__super__.constructor.apply(this, arguments);
    return _ref37;
  }

  return Case;

})(Ellipsis);

Actor = (function(_super) {
  __extends(Actor, _super);

  function Actor() {
    var _this = this;
    Actor.__super__.constructor.apply(this, arguments);
    this.anchors[cardinal.E] = function() {
      return {
        x: _this.x + (_this.width() - _this["super"]('txt_width')) / 2,
        y: _this.y
      };
    };
    this.anchors[cardinal.W] = function() {
      return {
        x: _this.x - (_this.width() - _this["super"]('txt_width')) / 2,
        y: _this.y
      };
    };
  }

  Actor.prototype.txt_y = function() {
    return this.height() / 2 - this["super"]('txt_height') + 2 + this.margin.y;
  };

  Actor.prototype.txt_height = function() {
    return Actor.__super__.txt_height.call(this) + 50;
  };

  Actor.prototype.txt_width = function() {
    return Actor.__super__.txt_width.call(this) + 25;
  };

  Actor.prototype.path = function() {
    var bottom, hstick, wstick;
    wstick = (this.width() - this["super"]('txt_width')) / 2;
    hstick = (this.height() - this["super"]('txt_height')) / 4;
    bottom = this.txt_y() - this.margin.y;
    return "M " + (-wstick) + " " + bottom + "         L 0 " + (bottom - hstick) + "         M " + wstick + " " + bottom + "         L 0 " + (bottom - hstick) + "         M 0 " + (bottom - hstick) + "         L 0 " + (bottom - 2 * hstick) + "         M " + (-wstick) + " " + (bottom - 1.75 * hstick) + "         L " + wstick + " " + (bottom - 2.25 * hstick) + "         M 0 " + (bottom - 2 * hstick) + "         L 0 " + (bottom - 3 * hstick) + "         A " + (.5 * wstick) + " " + (.5 * hstick) + " 0 1 1 0 " + (bottom - 4 * hstick) + "         A " + (.5 * wstick) + " " + (.5 * hstick) + " 0 1 1 0 " + (bottom - 3 * hstick) + "         ";
  };

  return Actor;

})(Element);

System = (function(_super) {
  __extends(System, _super);

  function System() {
    _ref38 = System.__super__.constructor.apply(this, arguments);
    return _ref38;
  }

  return System;

})(Group);

UseCase = (function(_super) {
  __extends(UseCase, _super);

  UseCase.prototype.label = 'UML Use Case Diagram';

  function UseCase() {
    UseCase.__super__.constructor.apply(this, arguments);
    this.linkstyle = 'diagonal';
    this.types = {
      elements: [Actor, Case],
      groups: [System],
      links: uml_links
    };
  }

  return UseCase;

})(Diagram);

Diagram.diagrams['UseCase'] = UseCase;

Electric = (function(_super) {
  __extends(Electric, _super);

  function Electric() {
    _ref39 = Electric.__super__.constructor.apply(this, arguments);
    return _ref39;
  }

  Electric.resizeable = false;

  Electric.rotationable = true;

  Electric.prototype.anchor_list = function() {
    return [cardinal.W, cardinal.E];
  };

  Electric.prototype.base_height = function() {
    return 20;
  };

  Electric.prototype._base_width = function() {
    return 20;
  };

  Electric.prototype.base_width = function() {
    return this._base_width() + 2 * this.wire_margin();
  };

  Electric.prototype.wire_margin = function() {
    return 10;
  };

  Electric.prototype.txt_y = function() {
    return this.height() / 2 + this.margin.y;
  };

  Electric.prototype.txt_height = function() {
    return this.base_height();
  };

  Electric.prototype.txt_width = function() {
    return this.base_width();
  };

  return Electric;

})(Element);

Node = (function(_super) {
  __extends(Node, _super);

  Node.fill = 'fg';

  function Node() {
    Node.__super__.constructor.apply(this, arguments);
    this.margin.x = 0;
    this.margin.y = 0;
    this.text = '';
  }

  Node.prototype.base_width = function() {
    return this._base_width() / 4;
  };

  Node.prototype.base_height = function() {
    return Node.__super__.base_height.call(this) / 4;
  };

  Node.prototype.anchor_list = function() {
    return [cardinal.N, cardinal.S, cardinal.W, cardinal.E];
  };

  Node.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M 0 " + (-h2) + "         A " + w2 + " " + h2 + " 0 0 1 0 " + h2 + "         A " + w2 + " " + h2 + " 0 0 1 0 " + (-h2) + "            ";
  };

  return Node;

})(Electric);

Resistor = (function(_super) {
  __extends(Resistor, _super);

  function Resistor() {
    _ref40 = Resistor.__super__.constructor.apply(this, arguments);
    return _ref40;
  }

  Resistor.fill = 'none';

  Resistor.prototype._base_width = function() {
    return Resistor.__super__._base_width.call(this) * 3;
  };

  Resistor.prototype.path = function() {
    var h2, lw2, path, w, w2, _i;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    lw2 = w2 - this.wire_margin();
    path = "M " + (-w2) + " 0                L " + (-lw2) + " 0";
    for (w = _i = -3; _i <= 2; w = ++_i) {
      path = "" + path + " L " + (lw2 * w / 3 + lw2 / 6) + " " + (h2 * (w % 2 ? -1 : 1));
    }
    return "" + path + "         L " + lw2 + " 0         L " + w2 + " 0";
  };

  return Resistor;

})(Electric);

Diode = (function(_super) {
  __extends(Diode, _super);

  function Diode() {
    _ref41 = Diode.__super__.constructor.apply(this, arguments);
    return _ref41;
  }

  Diode.prototype.path = function() {
    var h2, lw2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    lw2 = w2 - this.wire_margin();
    return "M " + (-w2) + " 0         L " + (-lw2) + " 0         M " + (-lw2) + " " + (-h2) + "         L " + lw2 + " 0         L " + lw2 + " " + (-h2) + "         L " + lw2 + " " + h2 + "         L " + lw2 + " 0         L " + (-lw2) + " " + h2 + "        z         M " + lw2 + " 0         L " + w2 + " 0        ";
  };

  return Diode;

})(Electric);

Battery = (function(_super) {
  __extends(Battery, _super);

  function Battery() {
    _ref42 = Battery.__super__.constructor.apply(this, arguments);
    return _ref42;
  }

  Battery.fill = 'fg';

  Battery.prototype._base_width = function() {
    return Battery.__super__._base_width.call(this) / 3;
  };

  Battery.prototype.base_height = function() {
    return Battery.__super__.base_height.call(this) * 2;
  };

  Battery.prototype.path = function() {
    var h2, h4, lw2, lw4, w2;
    w2 = this.width() / 2;
    lw2 = w2 - this.wire_margin();
    lw4 = lw2 / 2;
    h2 = this.height() / 2;
    h4 = h2 / 2;
    return "M " + (-w2) + " 0         L " + (-lw2) + " 0         M " + (-lw2) + " " + (-h4) + "         L " + (-lw4) + " " + (-h4) + "         L " + (-lw4) + " " + h4 + "         L " + (-lw2) + " " + h4 + "         z         M " + lw2 + " " + (-h2) + "         L " + lw2 + " " + h2 + "         M " + lw2 + " 0         L " + w2 + " 0        ";
  };

  return Battery;

})(Electric);

Transistor = (function(_super) {
  __extends(Transistor, _super);

  function Transistor() {
    var _this = this;
    Transistor.__super__.constructor.apply(this, arguments);
    this.anchors[cardinal.N] = function() {
      return {
        x: _this.x + (_this.width() / 2 - _this.wire_margin()) * .6,
        y: _this.y - _this.height() / 2
      };
    };
    this.anchors[cardinal.S] = function() {
      return {
        x: _this.x + (_this.width() / 2 - _this.wire_margin()) * .6,
        y: _this.y + _this.height() / 2
      };
    };
  }

  Transistor.prototype.base_width = function() {
    return 2 * this._base_width() + 2 * this.wire_margin();
  };

  Transistor.prototype.base_height = function() {
    return 2 * Transistor.__super__.base_height.call(this) + 2 * this.wire_margin();
  };

  Transistor.prototype.anchor_list = function() {
    return [cardinal.W, cardinal.N, cardinal.S];
  };

  Transistor.prototype.wire_margin = function() {
    return Transistor.__super__.wire_margin.call(this);
  };

  Transistor.prototype.path = function() {
    var h2, hI, hv, hw, lh2, lw2, w2, wI, ww;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    lw2 = w2 - this.wire_margin();
    lh2 = h2 - this.wire_margin();
    wI = lw2 / 4;
    hI = lh2 * .6;
    hv = hI / 2;
    ww = lw2 * .6;
    hw = lh2 * .8;
    return "         M " + (-w2) + " 0         L " + (-lw2) + " 0         A " + lw2 + " " + lw2 + " 0 1 1 " + lw2 + " 0         A " + lw2 + " " + lw2 + " 0 1 1 " + (-lw2) + " 0         L " + (-wI) + " 0         M " + (-wI) + " " + (-hI) + "         L " + (-wI) + " " + hI + "         M " + (-wI) + " " + (-hv) + "         L " + ww + " " + (-hw) + "         M " + ww + " " + (-hw) + "         L " + ww + " " + (-h2) + "         M " + (-wI) + " " + hv + "         L " + ww + " " + hw + "         L " + ww + " " + h2 + "        ";
  };

  return Transistor;

})(Electric);

PNPTransistor = (function(_super) {
  __extends(PNPTransistor, _super);

  function PNPTransistor() {
    _ref43 = PNPTransistor.__super__.constructor.apply(this, arguments);
    return _ref43;
  }

  PNPTransistor.prototype.path = function() {
    var h2, ha, hb, hw, lh2, lw2, w2, wa, wb, ww;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    lw2 = w2 - this.wire_margin();
    lh2 = h2 - this.wire_margin();
    ww = lw2 * .6;
    hw = lh2 * .8;
    wa = lw2 * .1;
    ha = lh2 * .7;
    wb = lw2 * .3;
    hb = lh2 * .4;
    return "" + (PNPTransistor.__super__.path.call(this)) + "        M " + ww + " " + (-hw) + "        L " + wa + " " + (-ha) + "        M " + ww + " " + (-hw) + "        L " + wb + " " + (-hb) + "        ";
  };

  return PNPTransistor;

})(Transistor);

NPNTransistor = (function(_super) {
  __extends(NPNTransistor, _super);

  function NPNTransistor() {
    _ref44 = NPNTransistor.__super__.constructor.apply(this, arguments);
    return _ref44;
  }

  NPNTransistor.prototype.path = function() {
    var h2, ha, hb, hw, lh2, lw2, w2, wa, wb, ww;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    lw2 = w2 - this.wire_margin();
    lh2 = h2 - this.wire_margin();
    ww = lw2 * .6;
    hw = lh2 * .8;
    wa = lw2 * .1;
    ha = lh2 * .7;
    wb = lw2 * .3;
    hb = lh2 * .4;
    return "" + (NPNTransistor.__super__.path.call(this)) + "        M " + ww + " " + hw + "        L " + wa + " " + ha + "        M " + ww + " " + hw + "        L " + wb + " " + hb + "        ";
  };

  return NPNTransistor;

})(Transistor);

Wire = (function(_super) {
  __extends(Wire, _super);

  function Wire() {
    _ref45 = Wire.__super__.constructor.apply(this, arguments);
    return _ref45;
  }

  Wire.prototype.path = function() {
    var c1, c2, path, _ref46;
    c1 = this.source.pos();
    c2 = this.target.pos();
    if (void 0 === c1.x || void 0 === c1.y || void 0 === c2.x || void 0 === c2.y) {
      return 'M 0 0';
    }
    this.d1 = this.source_anchor || this.source.direction(c2.x, c2.y);
    this.a1 = this.source.rotate(this.source.anchors[this.d1]());
    this.d2 = this.target_anchor || this.target.direction(c1.x, c1.y);
    this.a2 = this.target.rotate(this.target.anchors[this.d2]());
    path = "M " + this.a1.x + " " + this.a1.y + " L";
    if ((_ref46 = angle_to_cardinal(this.source._rotation)) === 'E' || _ref46 === 'W') {
      path = "" + path + " " + this.a2.x + " " + this.a1.y + " L";
    } else {
      path = "" + path + " " + this.a1.x + " " + this.a2.y + " L";
    }
    return "" + path + " " + this.a2.x + " " + this.a2.y;
  };

  return Wire;

})(Link);

ElectricDiagram = (function(_super) {
  __extends(ElectricDiagram, _super);

  ElectricDiagram.prototype.label = 'Electric Diagram';

  function ElectricDiagram() {
    ElectricDiagram.__super__.constructor.apply(this, arguments);
    this.types = {
      elements: [Diode, Resistor, Node, Battery, NPNTransistor, PNPTransistor],
      groups: [],
      links: [Wire]
    };
  }

  return ElectricDiagram;

})(Diagram);

Diagram.diagrams['ElectricDiagram'] = ElectricDiagram;

Class = (function(_super) {
  __extends(Class, _super);

  function Class() {
    _ref46 = Class.__super__.constructor.apply(this, arguments);
    return _ref46;
  }

  Class.prototype.shift = 10;

  Class.prototype.height = function() {
    return Class.__super__.height.call(this) + this.shift * 2;
  };

  Class.prototype.txt_y = function() {
    return Class.__super__.txt_y.call(this) - this.shift;
  };

  Class.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "" + (Class.__super__.path.call(this)) + "         M " + (-w2) + " " + (h2 - this.shift) + "         L " + w2 + " " + (h2 - this.shift) + "         M " + (-w2) + " " + (h2 - 2 * this.shift) + "         L " + w2 + " " + (h2 - 2 * this.shift) + "        ";
  };

  return Class;

})(Rect);

ClassDiagram = (function(_super) {
  __extends(ClassDiagram, _super);

  ClassDiagram.prototype.label = 'UML Class Diagram';

  function ClassDiagram() {
    ClassDiagram.__super__.constructor.apply(this, arguments);
    this.linkstyle = 'diagonal';
    this.types = {
      elements: [Class].concat(uml_elements),
      groups: [System],
      links: uml_links
    };
  }

  return ClassDiagram;

})(Diagram);

Diagram.diagrams['ClassDiagram'] = ClassDiagram;

order = function(a, b) {
  return d3.ascending(a.ts, b.ts);
};

node_add = function(type) {
  var dom_node, mouse_evt, new_node, nth, set, x, y;
  x = diagram.mouse.x;
  y = diagram.mouse.y;
  if (new type() instanceof Group) {
    set = diagram.groups;
    diagram.last_types.group = type;
  } else {
    set = diagram.elements;
    diagram.last_types.element = type;
  }
  nth = set.filter(function(node) {
    return node instanceof type;
  }).length + 1;
  new_node = new type(x, y, "" + type.name + " #" + nth, !diagram.force);
  set.push(new_node);
  if (d3.event) {
    diagram.selection = [new_node];
  }
  svg.sync(true);
  if (d3.event) {
    dom_node = null;
    svg.svg.selectAll('g.node').each(function(node) {
      if (node === new_node) {
        return dom_node = this;
      }
    });
    mouse_evt = document.createEvent('MouseEvent');
    mouse_evt.initMouseEvent(d3.event.type, d3.event.canBubble, d3.event.cancelable, d3.event.view, d3.event.detail, d3.event.screenX, d3.event.screenY, d3.event.clientX, d3.event.clientY, d3.event.ctrlKey, d3.event.altKey, d3.event.shiftKey, d3.event.metaKey, d3.event.button, d3.event.relatedTarget);
    return dom_node.dispatchEvent(mouse_evt);
  }
};

commands = {
  undo: {
    fun: function(e) {
      history.go(-1);
      return e != null ? e.preventDefault() : void 0;
    },
    label: 'Undo',
    glyph: 'chevron-left',
    hotkey: 'ctrl+z'
  },
  redo: {
    fun: function(e) {
      history.go(1);
      return e != null ? e.preventDefault() : void 0;
    },
    label: 'Redo',
    glyph: 'chevron-right',
    hotkey: 'ctrl+y'
  },
  save: {
    fun: function(e) {
      save();
      return e != null ? e.preventDefault() : void 0;
    },
    label: 'Save locally',
    glyph: 'save',
    hotkey: 'ctrl+s'
  },
  edit: {
    fun: function() {
      return edit((function() {
        if (diagram.selection.length === 1) {
          return diagram.selection[0].text;
        } else {
          return '';
        }
      }), (function(txt) {
        var node, _i, _len, _ref47, _results;
        _ref47 = diagram.selection;
        _results = [];
        for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
          node = _ref47[_i];
          _results.push(node.text = txt);
        }
        return _results;
      }));
    },
    label: 'Edit elements text',
    glyph: 'edit',
    hotkey: 'e'
  },
  remove: {
    fun: function() {
      var lnk, node, _i, _j, _len, _len1, _ref47, _ref48;
      _ref47 = diagram.selection;
      for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
        node = _ref47[_i];
        if (__indexOf.call(diagram.groups, node) >= 0) {
          diagram.groups.splice(diagram.groups.indexOf(node), 1);
        } else if (__indexOf.call(diagram.elements, node) >= 0) {
          diagram.elements.splice(diagram.elements.indexOf(node), 1);
        } else if (__indexOf.call(diagram.links, node) >= 0) {
          diagram.links.splice(diagram.links.indexOf(node), 1);
        }
        _ref48 = diagram.links.slice();
        for (_j = 0, _len1 = _ref48.length; _j < _len1; _j++) {
          lnk = _ref48[_j];
          if (node === lnk.source || node === lnk.target) {
            diagram.links.splice(diagram.links.indexOf(lnk), 1);
          }
        }
      }
      diagram.selection = [];
      return svg.sync(true);
    },
    label: 'Remove elements',
    glyph: 'remove-sign',
    hotkey: 'del'
  },
  select_all: {
    fun: function(e) {
      diagram.selection = diagram.nodes().concat(diagram.links);
      svg.tick();
      return e != null ? e.preventDefault() : void 0;
    },
    label: 'Select all elements',
    glyph: 'fullscreen',
    hotkey: 'ctrl+a'
  },
  force: {
    fun: function(e) {
      if (diagram.force) {
        diagram.force.stop();
        diagram.force = null;
        return;
      }
      diagram.start_force();
      return e != null ? e.preventDefault() : void 0;
    },
    label: 'Toggle force',
    glyph: 'send',
    hotkey: 'tab'
  },
  linkstyle: {
    fun: function() {
      diagram.linkstyle = (function() {
        switch (diagram.linkstyle) {
          case 'curve':
            return 'diagonal';
          case 'diagonal':
            return 'rectangular';
          case 'rectangular':
            return 'demicurve';
          case 'demicurve':
            return 'curve';
        }
      })();
      return svg.tick();
    },
    label: 'Change link style',
    glyph: 'retweet',
    hotkey: 'space'
  },
  defaultscale: {
    fun: function() {
      svg.zoom.scale(1);
      svg.zoom.translate([0, 0]);
      return svg.zoom.event(d3.select('.background'));
    },
    label: 'Reset view',
    glyph: 'screenshot',
    hotkey: 'ctrl+backspace'
  },
  snaptogrid: {
    fun: function() {
      var node, _i, _len, _ref47;
      _ref47 = diagram.nodes();
      for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
        node = _ref47[_i];
        node.x = node.px = diagram.snap.x * Math.floor(node.x / diagram.snap.x);
        node.y = node.py = diagram.snap.y * Math.floor(node.y / diagram.snap.y);
      }
      return svg.tick();
    },
    label: 'Snap to grid',
    glyph: 'magnet',
    hotkey: 'ctrl+space'
  },
  "switch": {
    fun: function() {
      var link, node, _i, _j, _len, _len1, _ref47, _ref48, _ref49, _ref50;
      _ref47 = diagram.selection;
      for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
        node = _ref47[_i];
        if (node instanceof Link) {
          _ref48 = [node.target, node.source], node.source = _ref48[0], node.target = _ref48[1];
        }
        if (node instanceof Element) {
          _ref49 = diagram.links;
          for (_j = 0, _len1 = _ref49.length; _j < _len1; _j++) {
            link = _ref49[_j];
            _ref50 = [link.target, link.source], link.source = _ref50[0], link.target = _ref50[1];
          }
        }
      }
      return svg.tick();
    },
    label: 'Switch link direction',
    glyph: 'transfer',
    hotkey: 'w'
  }
};

$(function() {
  var button, command, name, _results;
  _results = [];
  for (name in commands) {
    command = commands[name];
    button = d3.select('.btns').append('button').attr('title', "" + command.label + " [" + command.hotkey + "]").attr('class', 'btn btn-default btn-sm').on('click', command.fun);
    if (command.glyph) {
      button.append('span').attr('class', "glyphicon glyphicon-" + command.glyph);
    }
    _results.push(Mousetrap.bind(command.hotkey, command.fun));
  }
  return _results;
});

init_commands = function() {
  var e, e1, e2, element, fun, hotkey, i, icon, key, l, link, margin, n, svgicon, taken_hotkeys, _i, _j, _len, _len1, _ref47, _ref48, _results;
  taken_hotkeys = [];
  $('aside .icons .specific').each(function() {
    return Mousetrap.unbind($(this).attr('data-hotkey'));
  });
  $('aside .icons svg').remove();
  $('aside h3').attr('id', diagram.cls.name).addClass('specific').text(diagram.label);
  _ref47 = diagram.types.elements.concat(diagram.types.groups);
  for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
    e = _ref47[_i];
    i = 1;
    key = e.name[0].toLowerCase();
    while (i < e.length && __indexOf.call(taken_hotkeys, key) >= 0) {
      key = e[i++].toLowerCase();
    }
    taken_hotkeys.push(key);
    fun = (function(node) {
      return function() {
        return node_add(node);
      };
    })(e);
    hotkey = "a " + key;
    icon = new e(0, 0, e.name);
    if (icon instanceof Group) {
      icon._height = 70;
      icon._width = 90;
    }
    svgicon = d3.select('aside .icons').append('svg').attr('class', 'icon specific draggable btn btn-default').attr('title', "" + e.name + " [" + hotkey + "]").attr('data-hotkey', hotkey).on('mousedown', fun);
    element = svgicon.selectAll(icon instanceof Group ? 'g.group' : 'g.element').data([icon]);
    element.enter().call(enter_node);
    element.call(update_node);
    margin = 3;
    svgicon.attr('viewBox', "                " + (-icon.width() / 2 - margin) + "                " + (-icon.height() / 2 - margin) + "                " + (icon.width() + 2 * margin) + "                " + (icon.height() + 2 * margin)).attr('width', icon.width()).attr('height', icon.height()).attr('preserveAspectRatio', 'xMidYMid meet');
    Mousetrap.bind(hotkey, fun);
  }
  taken_hotkeys = [];
  _ref48 = diagram.types.links;
  _results = [];
  for (n = _j = 0, _len1 = _ref48.length; _j < _len1; n = ++_j) {
    l = _ref48[n];
    i = 1;
    key = l.name[0].toLowerCase();
    while (i < l.length && __indexOf.call(taken_hotkeys, key) >= 0) {
      key = l[i++].toLowerCase();
    }
    taken_hotkeys.push(key);
    hotkey = "l " + key;
    icon = new l(e1 = new Element(0, 0), e2 = new Element(100, 0));
    e1.set_txt_bbox({
      width: 10,
      height: 10
    });
    e2.set_txt_bbox({
      width: 10,
      height: 10
    });
    svgicon = d3.select('aside .icons').append('svg').attr('class', "icon specific btn btn-default link " + l.name).attr('title', "" + l.name + " [" + hotkey + "]").attr('data-hotkey', hotkey).classed('active', n === 0).on('mousedown', (function(lnk) {
      return function() {
        diagram.last_types.link = lnk;
        d3.selectAll('aside .icons .link').classed('active', false);
        return d3.select(this).classed('active', true);
      };
    })(l));
    link = svgicon.selectAll('g.link').data([icon]);
    link.enter().call(enter_link, false);
    link.call(update_link);
    svgicon.attr('height', 20).attr('viewBox', "0 -10 100 20").attr('preserveAspectRatio', 'none');
    _results.push(Mousetrap.bind(hotkey, fun));
  }
  return _results;
};

edit = function(getter, setter) {
  var overlay, textarea, textarea_node;
  overlay = d3.select('#overlay').classed('visible', true);
  textarea = overlay.select('textarea');
  textarea_node = textarea.node();
  textarea.on('input', function() {
    setter(this.value);
    return svg.sync(true);
  }).on('keydown', function() {
    if (d3.event.keyCode === 27) {
      textarea.on('input', null);
      textarea.on('keydown', null);
      textarea_node.value = '';
      return overlay.classed('visible', false);
    }
  });
  textarea_node.value = getter();
  textarea_node.select();
  textarea_node.focus();
  return overlay.on('click', function() {
    if (d3.event.target === this) {
      textarea.on('input', null);
      textarea.on('keydown', null);
      textarea_node.value = '';
      return overlay.classed('visible', false);
    }
  });
};

move_drag = d3.behavior.drag().on('dragstart', function(node) {
  if (d3.event.sourceEvent.which === !1 || d3.event.sourceEvent.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', true);
  svg.svg.classed('translating', true);
  return diagram.dragging = true;
}).on("drag", function(node) {
  var delta, x, y, _i, _j, _len, _len1, _ref47, _ref48, _ref49;
  if (!diagram.dragging || d3.event.sourceEvent.ctrlKey) {
    return;
  }
  x = diagram.force ? 'px' : 'x';
  y = diagram.force ? 'py' : 'y';
  if (_ref47 = !node, __indexOf.call(diagram.selection, _ref47) >= 0) {
    diagram.selection.push(node);
  }
  _ref48 = diagram.selection;
  for (_i = 0, _len = _ref48.length; _i < _len; _i++) {
    node = _ref48[_i];
    node.fixed = true;
  }
  if (d3.event.sourceEvent.shiftKey) {
    delta = {
      x: node[x] - d3.event.x,
      y: node[y] - d3.event.y
    };
  } else {
    delta = {
      x: node[x] - diagram.snap.x * Math.floor(d3.event.x / diagram.snap.x),
      y: node[y] - diagram.snap.y * Math.floor(d3.event.y / diagram.snap.y)
    };
  }
  _ref49 = diagram.selection;
  for (_j = 0, _len1 = _ref49.length; _j < _len1; _j++) {
    node = _ref49[_j];
    node[x] -= delta.x;
    node[y] -= delta.y;
  }
  if (diagram.force) {
    return diagram.force.resume();
  } else {
    return svg.tick();
  }
}).on('dragend', function(node) {
  var lnk, _i, _j, _len, _len1, _ref47, _ref48;
  svg.svg.classed('dragging', false);
  svg.svg.classed('translating', false);
  if (!diagram.dragging) {
    return;
  }
  _ref47 = diagram.nodes();
  for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
    node = _ref47[_i];
    node.fixed = false;
  }
  diagram.dragging = false;
  if (!$(d3.event.sourceEvent.target).closest('.inside').size()) {
    if (__indexOf.call(diagram.elements, node) >= 0) {
      diagram.elements.splice(diagram.elements.indexOf(node), 1);
    }
    if (__indexOf.call(diagram.groups, node) >= 0) {
      diagram.groups.splice(diagram.groups.indexOf(node), 1);
    }
    if (__indexOf.call(diagram.selection, node) >= 0) {
      diagram.selection.splice(diagram.selection.indexOf(node), 1);
    }
    _ref48 = diagram.links.slice();
    for (_j = 0, _len1 = _ref48.length; _j < _len1; _j++) {
      lnk = _ref48[_j];
      if (node === lnk.source || node === lnk.target) {
        diagram.links.splice(diagram.links.indexOf(lnk), 1);
      }
    }
  }
  return svg.sync(true);
});

nsweo_resize_drag = d3.behavior.drag().on("dragstart", function(handle) {
  var node;
  if (d3.event.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', true);
  svg.svg.classed('resizing', true);
  node = d3.select($(this).closest('.node').get(0)).data()[0];
  diagram._origin = mouse_xy(svg.svg.node());
  node.ox = node.x;
  node.oy = node.y;
  node.owidth = node.width();
  node.oheight = node.height();
  node.fixed = true;
  return d3.event.sourceEvent.stopPropagation();
}).on("drag", function(handle) {
  var angle, delta, m, node, nodes, shift, signs, x, y;
  if (d3.event.ctrlKey) {
    return;
  }
  nodes = d3.select($(this).closest('.node').get(0));
  node = nodes.data()[0];
  m = mouse_xy(svg.svg.node());
  if (handle === 'O') {
    delta = {
      x: m.x - node.x,
      y: m.y - node.y
    };
    angle = atan2(delta.y, delta.x) + pi / 2;
    if (!d3.event.sourceEvent.shiftKey) {
      angle = to_rad(diagram.snap.a * Math.floor(to_deg(angle) / diagram.snap.a));
    }
    node._rotation = angle;
  } else {
    delta = {
      x: m.x - diagram._origin.x,
      y: m.y - diagram._origin.y
    };
    delta = rotate(delta, 2 * pi - node._rotation);
    x = diagram.force ? 'px' : 'x';
    y = diagram.force ? 'py' : 'y';
    signs = cardinal_to_direction(handle);
    node.width(node.owidth + signs.x * delta.x);
    node.height(node.oheight + signs.y * delta.y);
    shift = {
      x: signs.x * (node.width() - node.owidth) / 2,
      y: signs.y * (node.height() - node.oheight) / 2
    };
    shift = rotate(shift, node._rotation);
    node[x] = node.ox + shift.x;
    node[y] = node.oy + shift.y;
    nodes.select('.shape').attr('d', node.path());
    nodes.select('.ghost').attr('d', Rect.prototype.path.apply(node));
    nodes.select('text').attr('x', node.txt_x()).attr('y', node.txt_y()).selectAll('tspan').attr('x', node.txt_x());
  }
  return svg.tick();
}).on("dragend", function(handle) {
  var node;
  if (d3.event.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', false);
  svg.svg.classed('resizing', false);
  node = d3.select($(this).closest('.node').get(0)).data()[0];
  node.ox = node.oy = node.owidth = node.oheight = null;
  node.fixed = false;
  return svg.sync(true);
});

anchor_link_drag = d3.behavior.drag().on("dragstart", function(anchor) {
  var link, node, type;
  if (d3.event.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', true);
  svg.svg.classed('linking', true);
  node = d3.select($(this).closest('.node').get(0)).data()[0];
  type = diagram.last_types.link || diagram.types.links[0];
  link = new type(node, diagram.mouse);
  link.source_anchor = anchor;
  diagram.linking.push(link);
  svg.sync(true);
  return d3.event.sourceEvent.stopPropagation();
}).on("drag", function(anchor) {
  var node;
  if (d3.event.ctrlKey) {
    return;
  }
  node = d3.select($(this).closest('.node').get(0)).data()[0];
  return svg.tick();
}).on("dragend", function(anchor) {
  var node;
  if (d3.event.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', false);
  svg.svg.classed('linking', false);
  node = d3.select($(this).closest('.node').get(0)).data()[0];
  diagram.linking = [];
  return svg.sync(true);
});

mouse_anchor = function(anchor) {
  var _this = this;
  return anchor.on("mousemove", function(anchor) {
    var lnk, node, _i, _len, _ref47, _results;
    if (d3.event.ctrlKey) {
      return;
    }
    d3.select(this).classed('active', true);
    node = d3.select($(this).closest('.node').get(0)).data()[0];
    _ref47 = diagram.linking;
    _results = [];
    for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
      lnk = _ref47[_i];
      if (lnk._drag && lnk._drag === 'source') {
        lnk.source_anchor = anchor;
        _results.push(lnk.source = node);
      } else {
        lnk.target_anchor = anchor;
        _results.push(lnk.target = node);
      }
    }
    return _results;
  }).on("mouseout", function(anchor) {
    var lnk, _i, _len, _ref47, _results;
    if (d3.event.ctrlKey) {
      return;
    }
    d3.select(this).classed('active', false);
    _ref47 = diagram.linking;
    _results = [];
    for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
      lnk = _ref47[_i];
      if (lnk._drag && lnk._drag === 'source') {
        lnk.source_anchor = null;
        _results.push(lnk.source = diagram.mouse);
      } else {
        lnk.target_anchor = null;
        _results.push(lnk.target = diagram.mouse);
      }
    }
    return _results;
  }).on("mouseup", function(anchor) {
    var lnk, node, _i, _len, _ref47, _ref48;
    if (d3.event.ctrlKey) {
      return;
    }
    node = d3.select($(_this).closest('.node').get(0)).data()[0];
    if (diagram.linking.length) {
      _ref47 = diagram.linking;
      for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
        lnk = _ref47[_i];
        if (lnk.source !== lnk.target && ((_ref48 = diagram.mouse) !== lnk.source && _ref48 !== lnk.target)) {
          diagram.links.push(lnk);
        }
      }
      diagram.linking = [];
      svg.sync(true);
      return d3.event.preventDefault();
    }
  });
};

mouse_node = function(node) {
  var _this = this;
  return node.on("mousedown", function(node) {
    var selected;
    if (d3.event.ctrlKey) {
      return;
    }
    selected = __indexOf.call(diagram.selection, node) >= 0;
    if ((selected && !diagram.dragging) || (!selected) && !d3.event.shiftKey) {
      diagram.selection = [node];
    }
    if (d3.event.shiftKey && !selected) {
      diagram.selection.push(node);
    }
    node.ts = timestamp();
    svg.svg.selectAll('g.node').sort(order);
    svg.svg.selectAll('g.element').each(function(elt) {
      if (__indexOf.call(diagram.selection, elt) < 0 && node.contains(elt)) {
        return diagram.selection.push(elt);
      }
    });
    return svg.tick();
  }).on("mousemove", function(node) {
    var lnk, _i, _len, _ref47, _results;
    if (d3.event.ctrlKey) {
      return;
    }
    _ref47 = diagram.linking;
    _results = [];
    for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
      lnk = _ref47[_i];
      if (lnk._drag && lnk._drag === 'source') {
        _results.push(lnk.source = node);
      } else {
        _results.push(lnk.target = node);
      }
    }
    return _results;
  }).on("mouseout", function(node) {
    var lnk, _i, _len, _ref47, _results;
    if (d3.event.ctrlKey) {
      return;
    }
    _ref47 = diagram.linking;
    _results = [];
    for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
      lnk = _ref47[_i];
      if (lnk._drag && lnk._drag === 'source') {
        _results.push(lnk.source = diagram.mouse);
      } else {
        _results.push(lnk.target = diagram.mouse);
      }
    }
    return _results;
  }).on("mouseup", function(node) {
    var lnk, _i, _len, _ref47, _ref48;
    if (d3.event.ctrlKey) {
      return;
    }
    if (diagram.linking.length) {
      _ref47 = diagram.linking;
      for (_i = 0, _len = _ref47.length; _i < _len; _i++) {
        lnk = _ref47[_i];
        if (lnk.source !== lnk.target && ((_ref48 = diagram.mouse) !== lnk.source && _ref48 !== lnk.target)) {
          diagram.links.push(lnk);
        }
      }
      diagram.linking = [];
      svg.sync(true);
      return d3.event.preventDefault();
    }
  }).on('dblclick', function(node) {
    if (d3.event.ctrlKey) {
      return;
    }
    return edit((function() {
      return node.text;
    }), (function(txt) {
      return node.text = txt;
    }));
  });
};

mouse_link = function(link) {
  return link.on('mousedown', function(lnk) {
    if (!d3.event.shiftKey) {
      diagram.selection = [];
    }
    diagram.selection.push(lnk);
    svg.tick();
    return d3.event.stopPropagation();
  }).on('dblclick', function(lnk) {
    var nearest;
    if (d3.event.ctrlKey) {
      return;
    }
    nearest = lnk.nearest(diagram.mouse);
    if (nearest === lnk.source) {
      return edit((function() {
        return lnk.text.source;
      }), (function(txt) {
        return lnk.text.source = txt;
      }));
    } else {
      return edit((function() {
        return lnk.text.target;
      }), (function(txt) {
        return lnk.text.target = txt;
      }));
    }
  });
};

link_drag = d3.behavior.drag().on("dragstart", function(link) {
  var nearest;
  if (d3.event.ctrlKey) {
    return;
  }
  if (Math.min(dist(diagram.mouse, link.a1), dist(diagram.mouse, link.a2)) > 60) {
    return;
  }
  svg.svg.classed('dragging', true);
  svg.svg.classed('linking', true);
  diagram.links.splice(diagram.links.indexOf(link), 1);
  nearest = link.nearest(diagram.mouse);
  if (link.source === nearest) {
    link.source = diagram.mouse;
    link.source_anchor = null;
    link._drag = 'source';
  } else {
    link.target = diagram.mouse;
    link.target_anchor = null;
    link._drag = 'target';
  }
  diagram.linking.push(link);
  svg.sync();
  return d3.event.sourceEvent.stopPropagation();
}).on("drag", function(anchor) {
  if (d3.event.ctrlKey) {
    return;
  }
  return svg.tick();
}).on("dragend", function(anchor) {
  if (d3.event.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', false);
  svg.svg.classed('linking', false);
  diagram.linking = [];
  return svg.sync(true);
});

enter_node = function(nodes, connect) {
  var g;
  if (connect == null) {
    connect = true;
  }
  g = nodes.append('g').attr('class', function(node) {
    return 'node ' + (node instanceof Group ? 'group' : 'element');
  });
  g.append('path').attr('class', 'ghost');
  g.append('path').attr('class', function(node) {
    return "shape fill-" + node.cls.fill + " stroke-" + node.cls.stroke;
  });
  g.append('text');
  if (!connect) {
    return;
  }
  g.append('g').attr('class', 'handles').each(function(node) {
    return d3.select(this).selectAll('.handle').data(node.handle_list()).enter().append('path').attr('class', function(handle) {
      return "handle " + handle;
    }).call(nsweo_resize_drag);
  });
  g.append('g').attr('class', 'anchors').each(function(node) {
    return d3.select(this).selectAll('.anchor').data(node.anchor_list()).enter().append('path').attr('class', function(anchor) {
      return "anchor " + anchor;
    }).call(mouse_anchor).call(anchor_link_drag);
  });
  g.call(move_drag);
  return g.call(mouse_node);
};

update_node = function(nodes) {
  nodes.select('text').each(function(node) {
    var i, line, tspan, txt, _i, _len, _ref47, _results;
    txt = d3.select(this);
    if (node.text === txt.text) {
      return;
    }
    txt.selectAll('tspan').remove();
    _ref47 = node.text.split('\n');
    _results = [];
    for (i = _i = 0, _len = _ref47.length; _i < _len; i = ++_i) {
      line = _ref47[i];
      tspan = txt.append('tspan').text(line).attr('x', 0);
      if (i !== 0) {
        _results.push(tspan.attr('dy', '1.2em'));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  }).each(function(node) {
    return node.set_txt_bbox(this.getBBox());
  }).attr('x', function(node) {
    return node.txt_x();
  }).attr('y', function(node) {
    return node.txt_y();
  }).selectAll('tspan').attr('x', function(node) {
    return node.txt_x();
  });
  nodes.select('.shape').attr('class', function(node) {
    return "shape fill-" + node.cls.fill + " stroke-" + node.cls.stroke;
  }).attr('d', function(node) {
    return node.path();
  });
  return nodes.select('.ghost').attr('d', function(node) {
    return Rect.prototype.path.apply(node);
  });
};

enter_link = function(links, connect) {
  var g;
  if (connect == null) {
    connect = true;
  }
  g = links.append('g').attr("class", "link");
  g.append("path").attr('class', 'ghost');
  g.append("path").attr('class', function(link) {
    return "shape " + link.cls.type;
  }).attr("marker-end", function(link) {
    return "url(#" + link.cls.marker.id + ")";
  });
  g.append("text").attr('class', "start");
  g.append("text").attr('class', "end");
  if (connect) {
    g.call(mouse_link);
    return g.call(link_drag);
  }
};

update_link = function(links) {
  links.each(function(link) {
    return $(this).find('path').attr('d', link.path());
  });
  links.select('text.start').each(function(link) {
    var i, line, tspan, txt, _i, _len, _ref47, _results;
    txt = d3.select(this);
    if (link.text.source === txt.text) {
      return;
    }
    txt.selectAll('tspan').remove();
    _ref47 = link.text.source.split('\n');
    _results = [];
    for (i = _i = 0, _len = _ref47.length; _i < _len; i = ++_i) {
      line = _ref47[i];
      tspan = txt.append('tspan').text(line).attr('x', 0);
      if (i !== 0) {
        _results.push(tspan.attr('dy', '1.2em'));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  });
  return links.select('text.end').each(function(link) {
    var i, line, tspan, txt, _i, _len, _ref47, _results;
    txt = d3.select(this);
    if (!link.text.target === txt.text) {
      return;
    }
    txt.selectAll('tspan').remove();
    _ref47 = link.text.target.split('\n');
    _results = [];
    for (i = _i = 0, _len = _ref47.length; _i < _len; i = ++_i) {
      line = _ref47[i];
      tspan = txt.append('tspan').text(line).attr('x', 0);
      if (i !== 0) {
        _results.push(tspan.attr('dy', '1.2em'));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  });
};

tick_node = function(nodes) {
  return nodes.attr("transform", (function(node) {
    return "translate(" + node.x + "," + node.y + ")rotate(" + (to_svg_angle(node._rotation)) + ")";
  })).classed('selected', function(node) {
    return __indexOf.call(diagram.selection, node) >= 0;
  }).each(function(node) {
    var s;
    s = node.cls.handle_size;
    d3.select(this).selectAll('.handle').data(node.handle_list()).attr('d', function(handle) {
      var h, signs;
      h = node.handles[handle]();
      if (handle !== 'O') {
        signs = cardinal_to_direction(handle);
        return "M " + h.x + " " + h.y + "                         L " + (h.x + signs.x * s) + " " + h.y + "                         L " + (h.x + signs.x * s) + " " + (h.y + signs.y * s) + "                         L " + h.x + " " + (h.y + signs.y * s) + "                        z";
      } else {
        return "M " + h.x + " " + h.y + "                         L " + h.x + " " + (h.y - 2 * s) + "                         A " + s + " " + s + " 0 1 1 " + h.x + " " + (h.y - 4 * s) + "                         A " + s + " " + s + " 0 1 1 " + h.x + " " + (h.y - 2 * s) + "                        ";
      }
    });
    return d3.select(this).selectAll('.anchor').data(node.anchor_list()).attr('transform', function(anchor) {
      var a;
      a = node.anchors[anchor]();
      return "rotate(" + (to_svg_angle(anchor)) + ", " + (a.x - node.x) + ", " + (a.y - node.y) + ")";
    }).attr('d', function(anchor) {
      var a;
      a = node.anchors[anchor]();
      if (void 0 === a.x || void 0 === a.y) {
        return 'M 0 0';
      }
      a.x -= node.x;
      a.y -= node.y;
      return "M " + a.x + " " + a.y + "                     L " + a.x + " " + (a.y + s) + "                     L " + (a.x + s) + " " + a.y + "                     L " + a.x + " " + (a.y - s) + "                     z";
    });
  });
};

tick_link = function(links) {
  links.classed('selected', function(link) {
    return __indexOf.call(diagram.selection, link) >= 0;
  });
  links.each(function(link) {
    return $(this).find('path').attr('d', link.path());
  });
  links.select('text.start').attr('transform', function(link) {
    var delta, pos;
    pos = {
      x: link.text_margin + this.getBBox().width / 2,
      y: -link.text_margin - this.getBBox().width / 2
    };
    delta = rotate(pos, link.o1);
    return "translate(" + (link.a1.x + delta.x) + ", " + (link.a1.y + delta.y) + ")";
  });
  return links.select('text.end').attr('transform', function(link) {
    var delta, pos;
    pos = {
      x: link.text_margin + this.getBBox().width / 2,
      y: -link.text_margin - this.getBBox().height / 2
    };
    delta = rotate(pos, link.o2);
    return "translate(" + (link.a2.x + delta.x) + ", " + (link.a2.y + delta.y) + ")";
  });
};

mouse_xy = function(e) {
  var m;
  m = d3.mouse(e);
  return {
    x: (m[0] - diagram.zoom.translate[0]) / diagram.zoom.scale,
    y: (m[1] - diagram.zoom.translate[1]) / diagram.zoom.scale
  };
};

Svg = (function(_super) {
  __extends(Svg, _super);

  function Svg() {
    this.create = __bind(this.create, this);
    var article, markers,
      _this = this;
    Svg.__super__.constructor.apply(this, arguments);
    article = d3.select("article").node();
    this.width = article.clientWidth;
    this.height = article.clientHeight || 500;
    this.title = d3.select('#editor h2').on('dblclick', function() {
      return edit((function() {
        return diagram.title;
      }), (function(txt) {
        return diagram.title = txt;
      }));
    });
    this.zoom = d3.behavior.zoom().scale(diagram.zoom.scale).translate(diagram.zoom.translate).scaleExtent([.15, 5]).on("zoom", function() {
      var _ref47;
      if (!d3.event.sourceEvent || ((_ref47 = d3.event.sourceEvent.type) === 'wheel' || _ref47 === 'click') || d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.which === 2) {
        diagram.zoom.translate = d3.event.translate;
        diagram.zoom.scale = d3.event.scale;
        d3.select('.root').attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        return d3.select('#grid').attr("patternTransform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
      } else {
        _this.zoom.scale(diagram.zoom.scale);
        return _this.zoom.translate(diagram.zoom.translate);
      }
    });
    d3.select("article").selectAll('svg').data([diagram]).enter().append("svg").attr('id', "diagram").attr("width", this.width).attr("height", this.height).call(this.create);
    this.svg = d3.select('#diagram');
    markers = this.svg.select('defs').selectAll('marker').data(diagram.markers());
    markers.enter().append('marker').attr('id', function(m) {
      return m.id;
    }).attr('viewBox', '-10 -10 30 30').attr('refX', 20).attr('refY', 5).attr('markerUnits', 'userSpaceOnUse').attr('markerWidth', 40).attr('markerHeight', 40).attr('orient', 'auto').append('path').attr('d', function(m) {
      return m.path();
    });
    markers.exit().remove();
    this.svg.on("mousedown", function(event) {
      var mouse;
      if (!d3.select(d3.event.target).classed('background') || d3.event.ctrlKey || d3.event.which === 2) {
        return;
      }
      if (d3.event.altKey && d3.event.shiftKey) {
        diagram.groupping = true;
      }
      if (!d3.event.shiftKey) {
        diagram.selection = [];
        svg.tick();
      }
      mouse = mouse_xy(_this.svg.node());
      _this.svg.select(diagram.groupping ? 'g.underlay' : 'g.overlay').append("rect").attr({
        "class": "selection",
        x: mouse.x,
        y: mouse.y,
        width: 0,
        height: 0
      });
      return d3.event.preventDefault();
    });
    d3.select(window).on("mousemove", function() {
      var mouse, move, rect, sel;
      if (d3.event.ctrlKey) {
        return;
      }
      mouse = mouse_xy(_this.svg.node());
      diagram.mouse.lasts.push({
        x: diagram.mouse.x - mouse.x,
        y: diagram.mouse.y - mouse.y
      });
      diagram.mouse.dynamic_rotation();
      diagram.mouse.lasts.shift();
      diagram.mouse.x = mouse.x;
      diagram.mouse.y = mouse.y;
      sel = _this.svg.select("rect.selection");
      if (!sel.empty()) {
        rect = {
          x: +sel.attr("x"),
          y: +sel.attr("y"),
          width: +sel.attr("width"),
          height: +sel.attr("height")
        };
        move = {
          x: mouse.x - rect.x,
          y: mouse.y - rect.y
        };
        if (move.x < 1 || (move.x * 2 < rect.width)) {
          rect.x = mouse.x;
          rect.width -= move.x;
        } else {
          rect.width = move.x;
        }
        if (move.y < 1 || (move.y * 2 < rect.height)) {
          rect.y = mouse.y;
          rect.height -= move.y;
        } else {
          rect.height = move.y;
        }
        rect.width = Math.max(0, rect.width);
        rect.height = Math.max(0, rect.height);
        sel.attr(rect);
        _this.svg.selectAll('g.node').each(function(elt) {
          var g, selected;
          g = d3.select(this);
          selected = __indexOf.call(diagram.selection, elt) >= 0;
          if (elt["in"](rect) && !selected) {
            return diagram.selection.push(elt);
          } else if (!elt["in"](rect) && selected && !d3.event.shiftKey) {
            return diagram.selection.splice(diagram.selection.indexOf(elt), 1);
          }
        });
        svg.tick();
        return d3.event.preventDefault();
      }
    }).on("mouseup", function() {
      var grp, height, nth, sel, type, width, x, y;
      if (d3.event.ctrlKey) {
        return;
      }
      if (diagram.linking.length) {
        diagram.linking = [];
        _this.sync();
      }
      if (diagram.groupping) {
        sel = _this.svg.select("rect.selection");
        x = +sel.attr("x");
        y = +sel.attr("y");
        width = +sel.attr("width");
        height = +sel.attr("height");
        type = diagram.last_types.group || diagram.types.groups[0];
        if (type) {
          nth = diagram.groups.filter(function(grp) {
            return grp instanceof type;
          }).length + 1;
          grp = new type(x + width / 2, y + height / 2, "" + type.name + " #" + nth, !diagram.force);
          grp._width = width;
          grp._height = height;
          diagram.groups.push(grp);
        }
        diagram.groupping = false;
        _this.sync();
      }
      _this.svg.selectAll("rect.selection").remove();
      return d3.event.preventDefault();
    }).on("keydown", function() {
      if (d3.event.ctrlKey) {
        return d3.select('.background').classed('move', true);
      }
    }).on("keyup", function() {
      return d3.select('.background').classed('move', false);
    });
  }

  Svg.prototype.create = function(svg) {
    var background, background_g, defs, pattern, root,
      _this = this;
    defs = svg.append('defs');
    background_g = svg.append('g').attr('id', 'bg');
    background = background_g.append('rect').attr('class', 'background').attr('width', this.width).attr('height', this.height).attr('fill', 'url(#grid)').call(this.zoom);
    d3.select(window).on('resize', function() {
      return _this.resize();
    });
    pattern = defs.append('pattern').attr('id', 'grid').attr('viewBox', '0 0 10 10').attr('x', 0).attr('y', 0).attr('width', diagram.snap.x).attr('height', diagram.snap.y).attr('patternUnits', 'userSpaceOnUse');
    pattern.append('path').attr('d', 'M 10 0 L 0 0 L 0 10');
    root = background_g.append('g').attr('class', 'root');
    root.append('g').attr('class', 'underlay');
    root.append('g').attr('class', 'groups');
    root.append('g').attr('class', 'links');
    root.append('g').attr('class', 'elements');
    return root.append('g').attr('class', 'overlay');
  };

  Svg.prototype.sync = function(persist) {
    var element, group, link;
    if (persist == null) {
      persist = false;
    }
    this.zoom.scale(diagram.zoom.scale);
    this.zoom.translate(diagram.zoom.translate);
    this.zoom.event(d3.select('#bg'));
    this.title.text(diagram.title);
    group = this.svg.select('g.groups').selectAll('g.group').data(diagram.groups.sort(order));
    element = this.svg.select('g.elements').selectAll('g.element').data(diagram.elements.sort(order));
    link = this.svg.select('g.links').selectAll('g.link').data(diagram.links.concat(diagram.linking));
    group.enter().call(enter_node);
    element.enter().call(enter_node);
    link.enter().call(enter_link);
    group.call(update_node);
    element.call(update_node);
    link.call(update_link);
    group.exit().remove();
    element.exit().remove();
    link.exit().remove();
    this.tick();
    if (persist) {
      generate_url();
    }
    if (diagram.force) {
      diagram.force.stop();
      diagram.force.nodes(diagram.nodes()).links(diagram.links);
      return diagram.force.start();
    }
  };

  Svg.prototype.tick = function() {
    this.svg.select('g.groups').selectAll('g.group').call(tick_node);
    this.svg.select('g.elements').selectAll('g.element').call(tick_node);
    return this.svg.select('g.links').selectAll('g.link').call(tick_link);
  };

  Svg.prototype.resize = function() {
    var article;
    article = d3.select("article").node();
    this.width = article.clientWidth;
    this.height = article.clientHeight || 500;
    this.svg.attr("width", this.width).attr("height", this.height);
    return d3.select('.background').attr("width", this.width).attr("height", this.height);
  };

  return Svg;

})(Base);

load = function(data) {
  var Type, e;
  Type = Diagram.diagrams[data.name];
  window.diagram = new Type();
  window.svg = new Svg();
  try {
    return diagram.loads(data);
  } catch (_error) {
    e = _error;
    return console.log(e);
  }
};

save = function() {
  return localStorage.setItem("" + diagram.cls.name + "|" + diagram.title, diagram.hash());
};

generate_url = function() {
  var hash;
  hash = '#' + diagram.hash();
  if (location.hash !== hash) {
    return history.pushState(null, null, hash);
  }
};

history_pop = function() {
  var $diagrams, $editor;
  $diagrams = $('#diagrams');
  $editor = $('#editor');
  if (!location.hash) {
    $diagrams.removeClass('hidden');
    $editor.addClass('hidden');
    list_diagrams();
    return;
  }
  $editor.removeClass('hidden');
  $diagrams.addClass('hidden');
  load(JSON.parse(decodeURIComponent(escape(atob(location.hash.slice(1))))));
  if (diagram.cls.name !== $('aside h3').attr('id')) {
    init_commands();
    svg.resize();
  }
  return svg.sync();
};

list_diagrams = function() {
  var $tbody, $tr, $ul, b64_diagram, diagram, key, name, title, type, _ref47, _ref48, _results;
  $tbody = $('#diagrams tbody');
  $tbody.find('.local').remove();
  for (key in localStorage) {
    b64_diagram = localStorage[key];
    _ref47 = key.split('|'), type = _ref47[0], title = _ref47[1];
    if (title == null) {
      continue;
    }
    $tbody.append($tr = $('<tr>'));
    $tr.addClass('local').append($('<td>').text(title), $('<td>').text(Diagram.diagrams[type].label), $('<td>').append($('<a>').attr('href', "#" + b64_diagram).text('⬈')));
  }
  $ul = $('#diagrams ul');
  $ul.children().remove();
  _ref48 = Diagram.diagrams;
  _results = [];
  for (name in _ref48) {
    type = _ref48[name];
    diagram = new type();
    b64_diagram = diagram.hash();
    _results.push($ul.append($('<li>').append($('<a>').attr('href', "#" + b64_diagram).text("New " + diagram.label))));
  }
  return _results;
};

KEYWORDS = ['node', 'edge', 'graph', 'digraph', 'subgraph', 'strict'];

BRACES = ['[', '{', '}', ']'];

DELIMITERS = [':', ';', ','];

OPERATORS = ['--', '->'];

RE_SPACE = /\s/;

RE_ALPHA = /\w/;

RE_DIGIT = /[\d|.]/;

RE_ALPHADIGIT = /[\d|\w]/;

PANIC_THRESHOLD = 9999;

Token = (function() {
  function Token(value) {
    this.value = value;
  }

  return Token;

})();

Keyword = (function(_super) {
  __extends(Keyword, _super);

  function Keyword() {
    _ref47 = Keyword.__super__.constructor.apply(this, arguments);
    return _ref47;
  }

  return Keyword;

})(Token);

Id = (function(_super) {
  __extends(Id, _super);

  function Id() {
    _ref48 = Id.__super__.constructor.apply(this, arguments);
    return _ref48;
  }

  return Id;

})(Token);

Number = (function(_super) {
  __extends(Number, _super);

  function Number() {
    _ref49 = Number.__super__.constructor.apply(this, arguments);
    return _ref49;
  }

  return Number;

})(Id);

QuotedId = (function(_super) {
  __extends(QuotedId, _super);

  function QuotedId() {
    _ref50 = QuotedId.__super__.constructor.apply(this, arguments);
    return _ref50;
  }

  return QuotedId;

})(Id);

Brace = (function(_super) {
  __extends(Brace, _super);

  function Brace() {
    _ref51 = Brace.__super__.constructor.apply(this, arguments);
    return _ref51;
  }

  return Brace;

})(Token);

Delimiter = (function(_super) {
  __extends(Delimiter, _super);

  function Delimiter() {
    _ref52 = Delimiter.__super__.constructor.apply(this, arguments);
    return _ref52;
  }

  return Delimiter;

})(Token);

Assign = (function(_super) {
  __extends(Assign, _super);

  function Assign() {
    _ref53 = Assign.__super__.constructor.apply(this, arguments);
    return _ref53;
  }

  return Assign;

})(Token);

Operator = (function(_super) {
  __extends(Operator, _super);

  function Operator() {
    _ref54 = Operator.__super__.constructor.apply(this, arguments);
    return _ref54;
  }

  return Operator;

})(Token);

dot_tokenize = function(s) {
  var chr, col, escape, id, last_chr, len, op, pos, row, token, tokens, _ref55, _ref56;
  pos = 0;
  row = 0;
  col = 0;
  len = s.length;
  tokens = [];
  last_chr = chr = null;
  while (pos < len) {
    last_chr = chr;
    token = null;
    col++;
    chr = s[pos++];
    if (chr.match(/\s/)) {
      if (chr === '\n') {
        row++;
        col = 0;
      }
      continue;
    } else if (chr === '=') {
      token = new Assign(chr);
    } else if (chr === '-') {
      op = chr + s[pos++];
      if (__indexOf.call(OPERATORS, op) >= 0) {
        token = new Operator(op);
      }
    } else if (__indexOf.call(BRACES, chr) >= 0) {
      token = new Brace(chr);
    } else if (__indexOf.call(DELIMITERS, chr) >= 0) {
      token = new Delimiter(chr);
    } else if (chr.match(/\w/)) {
      id = chr;
      while ((_ref55 = (chr = s[pos++])) != null ? _ref55.match(/\w|\d/) : void 0) {
        id += chr;
      }
      pos--;
      if (__indexOf.call(KEYWORDS, id) >= 0) {
        token = new Keyword(id);
      } else {
        token = new Id(id);
      }
    } else if (chr === '"') {
      id = '';
      escape = false;
      while (((chr = s[pos++]) !== '"' || escape) && (chr != null)) {
        if (chr === '\\' && !escape) {
          escape = true;
          continue;
        }
        if (escape) {
          if (chr === 'n') {
            chr = '\n';
          } else if (chr === 't') {
            chr = '\t';
          } else if (chr === 'r') {
            chr = '\r';
          } else if (chr === '"') {
            chr = '"';
          } else if (chr === '\\') {
            chr = '\\';
          } else if (chr === '\n') {
            chr = '';
          }
        }
        id += chr;
        escape = false;
      }
      token = new QuotedId(id);
    } else if (chr.match(/\d|\./)) {
      id = chr;
      while ((_ref56 = (chr = s[pos++])) != null ? _ref56.match(/\d|\./) : void 0) {
        id += chr;
      }
      token = new Number(parseFloat(id));
    } else if (chr.match(/\/|\#/)) {
      if (chr === '/' && s[pos] === '*') {
        pos += 2;
        while (!((chr = s[pos]) === '*' && s[pos + 1] === '/') && (chr != null)) {
          if (chr === '\n') {
            row++;
            col = 0;
          } else {
            col++;
          }
          pos++;
        }
        pos += 2;
      } else {
        if (chr === '#' || (chr === '/' && s[pos] === '/')) {
          while (!((chr = s[pos]) === '\n') && (chr != null)) {
            col++;
            pos++;
          }
        }
      }
    } else {
      throw "[Dot Tokenizer] Syntax error in dot " + chr + " at " + row + ", " + col;
    }
    if (token) {
      tokens.push(token);
    }
  }
  return tokens;
};

Graph = (function() {
  function Graph(type, id, strict) {
    this.type = type;
    this.id = id;
    this.strict = strict;
    this.statements = [];
  }

  return Graph;

})();

Statement = (function() {
  function Statement() {}

  return Statement;

})();

SubGraph = (function() {
  function SubGraph(id) {
    this.id = id;
    this.statements = [];
  }

  return SubGraph;

})();

Node = (function(_super) {
  __extends(Node, _super);

  function Node(id, port, compass_pt) {
    this.id = id;
    this.port = port;
    this.compass_pt = compass_pt;
  }

  return Node;

})(Statement);

Edge = (function(_super) {
  __extends(Edge, _super);

  function Edge() {
    this.nodes = [];
    this.attributes = [];
  }

  return Edge;

})(Statement);

Attribute = (function() {
  function Attribute(left, right) {
    this.left = left;
    this.right = right;
  }

  return Attribute;

})();

Attributes = (function(_super) {
  __extends(Attributes, _super);

  function Attributes(type) {
    this.type = type;
    this.attributes = [];
  }

  return Attributes;

})(Statement);

dot_lex = function(tokens) {
  var graph, id, level, parse_attribute, parse_attribute_list, parse_node, parse_node_list, parse_statement, parse_statement_list, parse_subgraph, pos, strict, type;
  pos = 0;
  level = 0;
  if (!(tokens[pos] instanceof Keyword)) {
    throw 'First token is not a keyword';
  }
  strict = false;
  if (tokens[pos].value === 'strict') {
    strict = true;
    pos++;
  }
  type = null;
  if (tokens[pos].value === 'graph') {
    type = 'normal';
  } else if (tokens[pos].value === 'digraph') {
    type = 'directed';
  }
  if (type === null) {
    throw 'Unknown graph type';
  }
  id = null;
  if (tokens[++pos] instanceof Id) {
    id = tokens[pos++].value;
  }
  parse_attribute = function() {
    var left, right;
    if (tokens[pos] instanceof Brace && tokens[pos].value === ']') {
      if (tokens[pos + 1] instanceof Brace && tokens[pos + 1].value === '[') {
        pos += 2;
      } else {
        return null;
      }
    }
    if (!(tokens[pos] instanceof Id)) {
      throw "Invalid left hand side of attribute '" + tokens[pos].value + "'";
    }
    left = tokens[pos].value;
    pos++;
    if (!(tokens[pos] instanceof Assign)) {
      throw "Invalid assignement '" + tokens[pos].value + "'";
    }
    pos++;
    if (!(tokens[pos] instanceof Id)) {
      throw "Invalid right hand side of attribute '" + tokens[pos].value + "'";
    }
    right = tokens[pos].value;
    return new Attribute(left, right);
  };
  parse_attribute_list = function() {
    var attribute, attributes, panic;
    if (!(tokens[pos] instanceof Brace && tokens[pos].value === '[')) {
      throw 'No opening brace "[" for attribute list';
    }
    pos++;
    attributes = [];
    panic = 0;
    while (panic++ < PANIC_THRESHOLD) {
      attribute = parse_attribute();
      pos++;
      if (attribute === null) {
        break;
      } else {
        attributes.push(attribute);
        if (tokens[pos] instanceof Delimiter && tokens[pos].value === ',') {
          pos++;
        }
      }
    }
    if (--panic === PANIC_THRESHOLD) {
      throw 'Infinite loop for statement list parsing';
    }
    return attributes;
  };
  parse_subgraph = function() {
    var subgraph;
    id = null;
    if (tokens[pos] instanceof Keyword && tokens[pos].value === 'subgraph') {
      pos++;
      if (tokens[pos] instanceof Id) {
        id = tokens[pos++].value;
      }
    }
    subgraph = new SubGraph(id);
    subgraph.statements = parse_statement_list();
    return subgraph;
  };
  parse_node = function() {
    var node;
    if (tokens[pos] instanceof Keyword && tokens[pos].value === 'subgraph') {
      node = parse_subgraph();
    } else if (tokens[pos] instanceof Brace && tokens[pos].value === '{') {
      node = parse_subgraph();
    } else {
      if (!(tokens[pos] instanceof Id)) {
        throw "Invalid edge id '" + tokens[pos].value + "'";
      }
      node = new Node(tokens[pos].value);
    }
    return node;
  };
  parse_node_list = function() {
    var node_list;
    node_list = [parse_node()];
    while (tokens[pos + 1] instanceof Operator) {
      pos += 2;
      node_list.push(parse_node());
    }
    return node_list;
  };
  parse_statement = function() {
    var statement, _ref55;
    if (tokens[pos] instanceof Brace && tokens[pos].value === '}') {
      return null;
    }
    if (tokens[pos] instanceof Brace && tokens[pos].value === '{') {
      statement = parse_subgraph();
    } else if (tokens[pos] instanceof Keyword) {
      if (tokens[pos].value === 'subgraph') {
        pos++;
        statement = parse_subgraph();
      } else if ((_ref55 = tokens[pos].value) === 'graph' || _ref55 === 'node' || _ref55 === 'edge') {
        statement = new Attributes(tokens[pos++].value);
        statement.attributes = parse_attribute_list();
        return statement;
      } else {
        throw 'Unexpected keyword ' + tokens[pos];
      }
    } else if (tokens[pos] instanceof Id) {
      if (tokens[pos + 1] instanceof Assign) {
        pos += 2;
        if (!(tokens[pos] instanceof Id)) {
          throw "Invalid right hand side of attribute '" + tokens[pos].value + "'";
        }
        statement = new Attribute(id, tokens[pos].value);
        return statement;
      }
      statement = new Edge();
      statement.nodes = parse_node_list();
      if (tokens[pos + 1] instanceof Brace && tokens[pos + 1].value === '[') {
        pos++;
        statement.attributes = parse_attribute_list();
      }
    } else {
      throw "Unexpected statement '" + tokens[pos].value + "'";
    }
    return statement;
  };
  parse_statement_list = function() {
    var panic, statement, statements;
    if (!(tokens[pos] instanceof Brace && tokens[pos].value === '{')) {
      throw 'No opening brace "{" for statement list';
    }
    pos++;
    statements = [];
    panic = 0;
    while (panic++ < PANIC_THRESHOLD) {
      statement = parse_statement();
      pos++;
      if (statement === null) {
        break;
      } else {
        statements.push(statement);
        if (tokens[pos] instanceof Delimiter && tokens[pos].value === ';') {
          pos++;
        }
      }
    }
    if (--panic === PANIC_THRESHOLD) {
      throw 'Infinite loop for statement list parsing';
    }
    return statements;
  };
  graph = new Graph(type, id, strict);
  graph.statements = parse_statement_list();
  return window.g = graph;
};

dot = function(src) {
  var d, edge, graph, i, link, link_type, mknode, node, nodes_by_id, statement, tokens, _i, _j, _len, _len1, _ref55, _ref56;
  mknode = function(l) {
    return new rectangle(void 0, void 0, l);
  };
  tokens = dot_tokenize(src);
  graph = dot_lex(tokens);
  d = window.diagram = new DotDiagram();
  window.svg = new Svg();
  nodes_by_id = {};
  d.title = graph.id;
  link_type = graph.type === 'directed' ? blackarrow : bare_link;
  _ref55 = graph.statements;
  for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
    statement = _ref55[_i];
    if (statement instanceof Edge) {
      _ref56 = statement.nodes;
      for (i = _j = 0, _len1 = _ref56.length; _j < _len1; i = ++_j) {
        edge = _ref56[i];
        if (!(edge.id in nodes_by_id)) {
          node = mknode(edge.id);
          d.elements.push(node);
          nodes_by_id[edge.id] = node;
        }
        if (i !== 0) {
          link = new link_type(nodes_by_id[statement.nodes[i - 1].id], nodes_by_id[edge.id]);
          d.links.push(link);
        }
      }
    }
  }
  d.force = true;
  return d.hash();
};

$(function() {
  if (location.pathname !== '/') {
    return;
  }
  list_diagrams();
  $('.dot2umlaut').click(function() {
    return location.hash = dot($(this).siblings('textarea.dot').val());
  });
  _this.addEventListener("popstate", history_pop);
  if (location.hash && (_this.mozInnerScreenX != null)) {
    return history_pop();
  }
});
