// Generated by CoffeeScript 1.6.3
var Actor, Aggregation, Arrow, Assign, Association, Attribute, Attributes, BRACES, Base, Battery, BlackArrow, BlackDiamond, Box, Brace, COMPASS_PTS, Case, Class, ClassDiagram, Comment, Composition, Container, CurveLink, DELIMITERS, Database, Decision, Delay, Delimiter, Diagram, Diamond, DiamondLink, Diode, Document, DotDiagram, Edge, Electric, ElectricDiagram, Element, Ellipse, Ellipsis, Flow, FlowChart, Graph, Group, HardDisk, IO, Id, Inheritance, InternalStorage, Junction, KEYWORDS, Keyword, Link, LinkStyle, LinkStyles, Lozenge, ManualInput, Marker, Mouse, NPNTransistor, Node, NoneLink, NormalLink, Note, Number, OPERATORS, OdiamondLink, OnormalLink, Operator, Oval, PANIC_THRESHOLD, PNPTransistor, Polygon, Preparation, Process, QuotedId, RE_ALPHA, RE_ALPHADIGIT, RE_DIGIT, RE_SPACE, Rect, Resistor, Statement, SubGraph, SubProcess, Svg, System, Terminator, Token, Transistor, UseCase, Void, WhiteArrow, WhiteDiamond, Wire, anchor_link_drag, angle_to_cardinal, atan2, capitalize, cardinal, cardinal_to_direction, commands, copy, dist, dot, dot_lex, dot_tokenize, edit, enter_link, enter_node, generate_url, history_pop, init_commands, last_command, link_drag, list_diagrams, load, merge, merge_copy, mod2pi, mouse_anchor, mouse_link, mouse_node, mouse_xy, move_drag, next, node_add, nsweo_resize_drag, order, pi, rotate, save, tick_link, tick_node, timestamp, to_deg, to_rad, to_svg_angle, uml_elements, uml_links, update_anchors, update_handles, update_link, update_node, wrap, write_text, zoom, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref27, _ref28, _ref29, _ref3, _ref30, _ref31, _ref32, _ref33, _ref34, _ref35, _ref36, _ref37, _ref38, _ref39, _ref4, _ref40, _ref41, _ref42, _ref43, _ref44, _ref45, _ref46, _ref47, _ref48, _ref49, _ref5, _ref50, _ref51, _ref52, _ref53, _ref54, _ref55, _ref56, _ref57, _ref58, _ref59, _ref6, _ref60, _ref61, _ref62, _ref7, _ref8, _ref9,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  _this = this,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

pi = Math.PI;

to_deg = function(a) {
  return 180 * a / pi;
};

to_rad = function(a) {
  return pi * a / 180;
};

dist = function(o, t) {
  return Math.sqrt(Math.pow(t.x - o.x, 2) + Math.pow(t.y - o.y, 2));
};

rotate = function(pos, a) {
  return {
    x: pos.x * Math.cos(a) - pos.y * Math.sin(a),
    y: pos.x * Math.sin(a) + pos.y * Math.cos(a)
  };
};

mod2pi = function(a) {
  return ((a % (2 * pi)) + 2 * pi) % (2 * pi);
};

atan2 = function(y, x) {
  return mod2pi(Math.atan2(y, x));
};

to_svg_angle = function(a) {
  return to_deg(mod2pi(a));
};

cardinal = {
  N: 3 * pi / 2,
  S: pi / 2,
  W: pi,
  E: 0
};

angle_to_cardinal = function(a) {
  if ((pi / 4 < a && a <= 3 * pi / 4)) {
    return 'S';
  }
  if ((3 * pi / 4 < a && a <= 5 * pi / 4)) {
    return 'W';
  }
  if ((5 * pi / 4 < a && a <= 7 * pi / 4)) {
    return 'N';
  }
  return 'E';
};

cardinal_to_direction = function(c) {
  switch (c) {
    case 'N':
      return {
        x: 0,
        y: -1
      };
    case 'S':
      return {
        x: 0,
        y: 1
      };
    case 'W':
      return {
        x: -1,
        y: 0
      };
    case 'E':
      return {
        x: 1,
        y: 0
      };
    case 'SE':
      return {
        x: 1,
        y: 1
      };
    case 'SW':
      return {
        x: -1,
        y: 1
      };
    case 'NW':
      return {
        x: -1,
        y: -1
      };
    case 'NE':
      return {
        x: 1,
        y: -1
      };
  }
};

timestamp = function() {
  return new Date().getTime();
};

capitalize = function(s) {
  return s.charAt(0).toUpperCase() + s.substr(1).toLowerCase();
};

next = function(o, k) {
  var keys;
  keys = Object.keys(o);
  return keys[(keys.indexOf(k) + 1) % keys.length];
};

merge = function(o1, o2) {
  var attr;
  for (attr in o2) {
    o1[attr] = o2[attr];
  }
  return o1;
};

copy = function(o) {
  var attr, c;
  c = {};
  for (attr in o) {
    c[attr] = o[attr];
  }
  return c;
};

merge_copy = function(o1, o2) {
  var attr, o3;
  o3 = {};
  for (attr in o1) {
    o3[attr] = o2[attr];
  }
  for (attr in o2) {
    o3[attr] = o2[attr];
  }
  return o3;
};

Base = (function() {
  function Base() {
    this.cls = this.constructor;
  }

  Base.prototype["super"] = function(fun, cls, args) {
    if (cls == null) {
      cls = null;
    }
    if (args == null) {
      args = [];
    }
    return (cls || this.cls).__super__[fun].apply(this, args);
  };

  return Base;

})();

LinkStyles = {};

LinkStyle = (function(_super) {
  __extends(LinkStyle, _super);

  function LinkStyle() {
    _ref = LinkStyle.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  LinkStyle.prototype.get = function(source, target, a1, a2, o1, o2) {
    return "M " + a1.x + " " + a1.y + " L " + a2.x + " " + a2.y;
  };

  return LinkStyle;

})(Base);

LinkStyles.Diagonal = (function(_super) {
  __extends(Diagonal, _super);

  function Diagonal() {
    _ref1 = Diagonal.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  return Diagonal;

})(LinkStyle);

LinkStyles.Rectangular = (function(_super) {
  __extends(Rectangular, _super);

  function Rectangular() {
    _ref2 = Rectangular.__super__.constructor.apply(this, arguments);
    return _ref2;
  }

  Rectangular.prototype.get = function(source, target, a1, a2, o1, o2) {
    var horizontal_1, horizontal_2, mid, path;
    horizontal_1 = Math.abs(o1 % pi) < pi / 4;
    horizontal_2 = Math.abs(o2 % pi) < pi / 4;
    path = "M " + a1.x + " " + a1.y + " L";
    if (!horizontal_1 && horizontal_2) {
      path = "" + path + " " + a1.x + " " + a2.y;
    } else if (horizontal_1 && !horizontal_2) {
      path = "" + path + " " + a2.x + " " + a1.y;
    } else if (horizontal_1 && horizontal_2) {
      mid = a1.x + .5 * (a2.x - a1.x);
      path = "" + path + " " + mid + " " + a1.y + " L " + mid + " " + a2.y;
    } else if (!horizontal_1 && !horizontal_2) {
      mid = a1.y + .5 * (a2.y - a1.y);
      path = "" + path + " " + a1.x + " " + mid + " L " + a2.x + " " + mid;
    }
    return "" + path + " L " + a2.x + " " + a2.y;
  };

  return Rectangular;

})(LinkStyle);

LinkStyles.Arc = (function(_super) {
  __extends(Arc, _super);

  function Arc() {
    _ref3 = Arc.__super__.constructor.apply(this, arguments);
    return _ref3;
  }

  Arc.prototype.get = function(source, target, a1, a2, o1, o2) {
    var horizontal_1, horizontal_2, path, rx, ry;
    horizontal_1 = Math.abs(o1 % pi) < pi / 4;
    horizontal_2 = Math.abs(o2 % pi) < pi / 4;
    rx = Math.abs(a1.x - a2.x);
    ry = Math.abs(a1.y - a2.y);
    return path = "M " + a1.x + " " + a1.y + " A " + rx + " " + ry + " 0 0 1 " + a2.x + " " + a2.y;
  };

  return Arc;

})(LinkStyle);

LinkStyles.Demicurve = (function(_super) {
  __extends(Demicurve, _super);

  function Demicurve() {
    _ref4 = Demicurve.__super__.constructor.apply(this, arguments);
    return _ref4;
  }

  Demicurve.prototype.get = function(source, target, a1, a2, o1, o2) {
    var horizontal_1, horizontal_2, m, path;
    horizontal_1 = Math.abs(o1 % pi) < pi / 4;
    horizontal_2 = Math.abs(o2 % pi) < pi / 4;
    path = "M " + a1.x + " " + a1.y + " C";
    m = {
      x: .5 * (a1.x + a2.x),
      y: .5 * (a1.y + a2.y)
    };
    if (horizontal_1) {
      path = "" + path + " " + m.x + " " + a1.y;
    } else {
      path = "" + path + " " + a1.x + " " + m.y;
    }
    if (horizontal_2) {
      path = "" + path + " " + m.x + " " + a2.y;
    } else {
      path = "" + path + " " + a2.x + " " + m.y;
    }
    return "" + path + " " + a2.x + " " + a2.y;
  };

  return Demicurve;

})(LinkStyle);

LinkStyles.Curve = (function(_super) {
  __extends(Curve, _super);

  function Curve() {
    _ref5 = Curve.__super__.constructor.apply(this, arguments);
    return _ref5;
  }

  Curve.prototype.get = function(source, target, a1, a2, o1, o2) {
    var d, dx, dy, path;
    path = "M " + a1.x + " " + a1.y + " C";
    d = dist(a1, a2, o1, o2) / 2;
    if (source === target) {
      d *= 4;
      if ((o1 + o2) % pi === 0) {
        o1 -= pi / 4;
        o2 += pi / 4;
      }
    }
    dx = Math.cos(o1) * d;
    dy = Math.sin(o1) * d;
    path = "" + path + " " + (a1.x + dx) + " " + (a1.y + dy);
    dx = Math.cos(o2) * d;
    dy = Math.sin(o2) * d;
    path = "" + path + " " + (a2.x + dx) + " " + (a2.y + dy);
    return "" + path + " " + a2.x + " " + a2.y;
  };

  return Curve;

})(LinkStyle);

LinkStyles.Rationalcurve = (function(_super) {
  __extends(Rationalcurve, _super);

  function Rationalcurve() {
    _ref6 = Rationalcurve.__super__.constructor.apply(this, arguments);
    return _ref6;
  }

  Rationalcurve.prototype.get = function(source, target, a1, a2, o1, o2) {
    var dx, dy, path;
    path = "M " + a1.x + " " + a1.y + " C";
    if (source === target) {
      if ((o1 + o2) % pi === 0) {
        o1 -= pi / 4;
        o2 += pi / 4;
      }
    }
    dx = Math.cos(o1) * source.width();
    dy = Math.sin(o1) * source.height();
    if (source === target) {
      dx *= 4;
      dy *= 4;
    }
    path = "" + path + " " + (a1.x + dx) + " " + (a1.y + dy);
    dx = Math.cos(o2) * target.width();
    dy = Math.sin(o2) * target.height();
    if (source === target) {
      dx *= 4;
      dy *= 4;
    }
    return path = "" + path + " " + (a2.x + dx) + " " + (a2.y + dy) + " " + a2.x + " " + a2.y;
  };

  return Rationalcurve;

})(LinkStyle);

Element = (function(_super) {
  __extends(Element, _super);

  Element.handle_size = 10;

  Element.resizeable = true;

  Element.rotationable = false;

  Element.fill = 'bg';

  Element.stroke = 'fg';

  function Element(x, y, text, fixed) {
    var _this = this;
    this.x = x;
    this.y = y;
    this.text = text;
    this.fixed = fixed != null ? fixed : false;
    Element.__super__.constructor.apply(this, arguments);
    this.ts = timestamp();
    this.margin = {
      x: 10,
      y: 5
    };
    this._width = null;
    this._height = null;
    this._rotation = 0;
    this.anchors = {};
    this.color = null;
    this.bg_color = null;
    this.anchors[cardinal.N] = function() {
      return {
        x: _this.x,
        y: _this.y - _this.height() / 2
      };
    };
    this.anchors[cardinal.E] = function() {
      return {
        x: _this.x + _this.width() / 2,
        y: _this.y
      };
    };
    this.anchors[cardinal.S] = function() {
      return {
        x: _this.x,
        y: _this.y + _this.height() / 2
      };
    };
    this.anchors[cardinal.W] = function() {
      return {
        x: _this.x - _this.width() / 2,
        y: _this.y
      };
    };
    this.handles = {
      NE: function() {
        return {
          x: _this.width() / 2,
          y: -_this.height() / 2
        };
      },
      NW: function() {
        return {
          x: -_this.width() / 2,
          y: -_this.height() / 2
        };
      },
      SW: function() {
        return {
          x: -_this.width() / 2,
          y: _this.height() / 2
        };
      },
      SE: function() {
        return {
          x: _this.width() / 2,
          y: _this.height() / 2
        };
      },
      O: function() {
        return {
          x: 0,
          y: -_this.height() / 2
        };
      }
    };
  }

  Element.prototype.rotate = function(pos, direct) {
    var ang, normed;
    if (direct == null) {
      direct = true;
    }
    if (void 0 === pos.x || void 0 === pos.y) {
      return null;
    }
    ang = direct ? this._rotation : 2 * pi - this._rotation;
    normed = {
      x: pos.x - this.x,
      y: pos.y - this.y
    };
    normed = rotate(normed, ang);
    normed.x += this.x;
    normed.y += this.y;
    return normed;
  };

  Element.prototype.anchor_list = function() {
    return [cardinal.N, cardinal.S, cardinal.W, cardinal.E];
  };

  Element.prototype.handle_list = function() {
    var l;
    l = [];
    if (this.cls.resizeable) {
      l = l.concat(['NW', 'NE', 'SW', 'SE']);
    }
    if (this.cls.rotationable) {
      l.push('O');
    }
    return l;
  };

  Element.prototype.pos = function() {
    return this.rotate({
      x: this.x,
      y: this.y
    });
  };

  Element.prototype.set_txt_bbox = function(bbox) {
    return this._txt_bbox = bbox;
  };

  Element.prototype.txt_width = function() {
    return this._txt_bbox.width + 2 * this.margin.x;
  };

  Element.prototype.txt_height = function() {
    return this._txt_bbox.height + 2 * this.margin.y;
  };

  Element.prototype.txt_x = function() {
    return 0;
  };

  Element.prototype.txt_y = function() {
    var lines;
    lines = this.text.split('\n').length;
    return this.margin.y - (this._txt_bbox.height * (lines - 1) / lines) / 2;
  };

  Element.prototype.width = function(w) {
    if (w == null) {
      w = null;
    }
    if (w !== null) {
      this._width = w;
    }
    return Math.max(this._width || 0, this.txt_width());
  };

  Element.prototype.height = function(h) {
    if (h == null) {
      h = null;
    }
    if (h !== null) {
      this._height = h;
    }
    return Math.max(this._height || 0, this.txt_height());
  };

  Element.prototype.direction = function(x, y) {
    var anchor, deviation, diff, min_anchor, min_diff, pi2, pos, target, _ref7;
    pi2 = 2 * pi;
    target = atan2(y - this.y, x - this.x);
    min_diff = Infinity;
    _ref7 = this.anchors;
    for (anchor in _ref7) {
      pos = _ref7[anchor];
      deviation = target - (+anchor) - this._rotation;
      diff = Math.min(Math.abs(deviation) % pi2, Math.abs(deviation - pi2) % pi2);
      if (diff < min_diff) {
        min_diff = diff;
        min_anchor = anchor;
      }
    }
    return +min_anchor;
  };

  Element.prototype["in"] = function(rect) {
    var _ref7, _ref8;
    return (rect.x < (_ref7 = this.x) && _ref7 < rect.x + rect.width) && (rect.y < (_ref8 = this.y) && _ref8 < rect.y + rect.height);
  };

  Element.prototype.contains = function() {
    return false;
  };

  Element.prototype.objectify = function() {
    return {
      name: this.constructor.name,
      x: this.x,
      y: this.y,
      width: this._width,
      height: this._height,
      rotation: this._rotation,
      text: this.text,
      fixed: this.fixed
    };
  };

  return Element;

})(Base);

Mouse = (function(_super) {
  __extends(Mouse, _super);

  Mouse.prototype.width = function() {
    return 1;
  };

  Mouse.prototype.height = function() {
    return 1;
  };

  Mouse.prototype.weight = 1;

  function Mouse() {
    var i, _i;
    Mouse.__super__.constructor.apply(this, arguments);
    this.lasts = [];
    for (i = _i = 0; _i <= 5; i = ++_i) {
      this.lasts.push({
        x: 0,
        y: 0
      });
    }
  }

  Mouse.prototype.dynamic_rotation = function() {
    return this._rotation = atan2(this.lasts.map(function(e) {
      return e.y;
    }).reduce((function(e, l) {
      return e + l;
    }), 0), this.lasts.map(function(e) {
      return e.x;
    }).reduce((function(e, l) {
      return e + l;
    }), 0));
  };

  return Mouse;

})(Element);

Marker = (function(_super) {
  __extends(Marker, _super);

  function Marker() {
    Marker.__super__.constructor.apply(this, arguments);
    this.id = this.constructor.name;
  }

  return Marker;

})(Base);

Void = (function(_super) {
  __extends(Void, _super);

  function Void() {
    _ref7 = Void.__super__.constructor.apply(this, arguments);
    return _ref7;
  }

  Void.prototype.path = function() {
    return 'M 0 0';
  };

  return Void;

})(Marker);

Arrow = (function(_super) {
  __extends(Arrow, _super);

  function Arrow() {
    _ref8 = Arrow.__super__.constructor.apply(this, arguments);
    return _ref8;
  }

  Arrow.prototype.path = function() {
    return 'M 10 0 L 20 5 L 10 10';
  };

  return Arrow;

})(Marker);

BlackArrow = (function(_super) {
  __extends(BlackArrow, _super);

  function BlackArrow() {
    _ref9 = BlackArrow.__super__.constructor.apply(this, arguments);
    return _ref9;
  }

  BlackArrow.prototype.path = function() {
    return "" + (BlackArrow.__super__.path.call(this)) + " z";
  };

  return BlackArrow;

})(Arrow);

Link = (function(_super) {
  __extends(Link, _super);

  Link.marker = new Void();

  Link.type = 'full';

  Link.prototype.text_margin = 10;

  function Link(source, target, text) {
    this.source = source;
    this.target = target;
    Link.__super__.constructor.apply(this, arguments);
    this.a1 = this.a2 = 0;
    this.text = {
      source: (text != null ? text.source : void 0) || '',
      target: (text != null ? text.target : void 0) || ''
    };
    this.color = null;
  }

  Link.prototype.objectify = function() {
    return {
      name: this.constructor.name,
      source: diagram.nodes().indexOf(this.source),
      target: diagram.nodes().indexOf(this.target),
      source_anchor: this.source_anchor,
      target_anchor: this.target_anchor,
      text: this.text
    };
  };

  Link.prototype.nearest = function(pos) {
    if (dist(pos, this.a1) < dist(pos, this.a2)) {
      return this.source;
    } else {
      return this.target;
    }
  };

  Link.prototype.path = function() {
    var c1, c2, d1, d2;
    c1 = this.source.pos();
    c2 = this.target.pos();
    if ((null === c1 || null === c2) || (void 0 === c1.x || void 0 === c1.y || void 0 === c2.x || void 0 === c2.y)) {
      return 'M 0 0';
    }
    d1 = +(this.source_anchor != null ? this.source_anchor : this.source.direction(c2.x, c2.y));
    this.a1 = this.source.rotate(this.source.anchors[d1]());
    d2 = +(this.target_anchor != null ? this.target_anchor : this.target.direction(this.a1.x, this.a1.y));
    if (this.source === this.target && d1 === d2) {
      d2 = +next(this.target.anchors, d1.toString());
    }
    this.a2 = this.target.rotate(this.target.anchors[d2]());
    this.o1 = d1 + this.source._rotation;
    this.o2 = d2 + this.target._rotation;
    return diagram.linkstyle.get(this.source, this.target, this.a1, this.a2, this.o1, this.o2);
  };

  return Link;

})(Base);

Diagram = (function(_super) {
  __extends(Diagram, _super);

  Diagram.diagrams = {};

  function Diagram() {
    Diagram.__super__.constructor.apply(this, arguments);
    this.title = 'Untitled ' + this.label;
    this.linkstyle = new LinkStyles.Rectangular();
    this.zoom = {
      scale: 1,
      translate: [0, 0]
    };
    this.elements = [];
    this.links = [];
    this.groups = [];
    this.snap = {
      x: 25,
      y: 25,
      a: 22.5
    };
    this.types = {};
    this.selection = [];
    this.linking = [];
    this.last_types = {
      link: null,
      element: null,
      group: null
    };
    this.mouse = new Mouse(0, 0, '');
    this.dragging = false;
    this.groupping = false;
    this.force_conf = {
      gravity: .1,
      distance: 20,
      strengh: 1,
      friction: .9,
      theta: .8,
      charge_base: 2000
    };
  }

  Diagram.prototype.start_force = function() {
    var _this = this;
    this.force = d3.layout.force().gravity(this.force_conf.gravity).linkDistance(this.force_conf.distance).linkStrength(this.force_conf.strengh).friction(this.force_conf.friction).theta(this.force_conf.theta).charge(function(node) {
      return -_this.force_conf.charge_base - node.width() * node.height() / 4;
    }).size([svg.width, svg.height]);
    this.force.on('tick', function() {
      return svg.tick();
    });
    this.force.on('end', generate_url);
    svg.sync();
    return this.force.start();
  };

  Diagram.prototype.markers = function() {
    var key, markers, type, val, _i, _len, _ref10, _results;
    markers = {};
    _ref10 = this.types.links;
    for (_i = 0, _len = _ref10.length; _i < _len; _i++) {
      type = _ref10[_i];
      markers[type.marker.id] = type.marker;
    }
    _results = [];
    for (key in markers) {
      val = markers[key];
      _results.push(val);
    }
    return _results;
  };

  Diagram.prototype.to_svg = function() {
    var content, css, margin, rect, rule, svg_clone, _i, _len, _ref10;
    css = '';
    _ref10 = d3.select('#style').node().sheet.cssRules;
    for (_i = 0, _len = _ref10.length; _i < _len; _i++) {
      rule = _ref10[_i];
      if (rule.selectorText.match(/^svg\s/)) {
        if (!rule.cssText.match(/:hover/) && !rule.cssText.match(/:active/) && !rule.cssText.match(/transition/)) {
          css += rule.cssText.replace(/svg\s/g, '');
        }
      }
    }
    svg_clone = d3.select(svg.svg.node().cloneNode(true));
    svg_clone.select('.background').remove();
    svg_clone.selectAll('.handles,.anchors').remove();
    svg_clone.selectAll('.node').classed('selected', false);
    svg_clone.selectAll('.ghost').remove();
    svg_clone.select('defs').append('style').text(css);
    margin = 50;
    rect = svg.svg.select('.root').node().getBoundingClientRect();
    svg_clone.select('.root').attr('transform', "translate(" + (diagram.zoom.translate[0] - rect.left + margin) + "," + (diagram.zoom.translate[1] - rect.top + margin) + ")scale(" + diagram.zoom.scale + ")");
    svg_clone.select('#title').attr('x', rect.width / 2 + margin);
    content = svg_clone.html();
    if (content == null) {
      content = $(svg_clone.node()).wrap('<div>').parent().html();
    }
    return "<svg xmlns='http://www.w3.org/2000/svg' width='" + (rect.width + 2 * margin) + "' height='" + (rect.height + 2 * margin) + "'>" + content + "</svg>";
  };

  Diagram.prototype.group = function(name) {
    var grp, _i, _len, _ref10;
    _ref10 = this.types.groups;
    for (_i = 0, _len = _ref10.length; _i < _len; _i++) {
      grp = _ref10[_i];
      if (grp.name === name) {
        return grp;
      }
    }
  };

  Diagram.prototype.element = function(name) {
    var elt, _i, _len, _ref10;
    _ref10 = this.types.elements;
    for (_i = 0, _len = _ref10.length; _i < _len; _i++) {
      elt = _ref10[_i];
      if (elt.name === name) {
        return elt;
      }
    }
  };

  Diagram.prototype.link = function(name) {
    var lnk, _i, _len, _ref10;
    _ref10 = this.types.links;
    for (_i = 0, _len = _ref10.length; _i < _len; _i++) {
      lnk = _ref10[_i];
      if (lnk.name === name) {
        return lnk;
      }
    }
  };

  Diagram.prototype.nodes = function() {
    return this.elements.concat(this.groups);
  };

  Diagram.prototype.objectify = function() {
    return {
      name: this.constructor.name,
      title: this.title,
      linkstyle: this.linkstyle.cls.name,
      zoom: this.zoom,
      elements: this.elements.map(function(elt) {
        return elt.objectify();
      }),
      groups: this.groups.map(function(grp) {
        return grp.objectify();
      }),
      links: this.links.map(function(lnk) {
        return lnk.objectify();
      }),
      force: this.force ? true : false
    };
  };

  Diagram.prototype.hash = function() {
    return LZString.compressToBase64(JSON.stringify(this.objectify()));
  };

  Diagram.prototype.loads = function(obj) {
    var element, element_type, elt, group, group_type, grp, link, link_type, lnk, _i, _j, _k, _len, _len1, _len2, _ref10, _ref11, _ref12;
    if (obj.title) {
      this.title = obj.title;
    }
    if (obj.linkstyle) {
      this.linkstyle = new LinkStyles[capitalize(obj.linkstyle)]();
    }
    if (obj.zoom) {
      this.zoom = obj.zoom;
    }
    _ref10 = obj.groups || [];
    for (_i = 0, _len = _ref10.length; _i < _len; _i++) {
      grp = _ref10[_i];
      group_type = this.group(grp.name);
      group = new group_type(grp.x, grp.y, grp.text, false);
      group._width = grp.width || null;
      group._height = grp.height || null;
      group._rotation = grp.rotation || 0;
      this.groups.push(group);
    }
    _ref11 = obj.elements;
    for (_j = 0, _len1 = _ref11.length; _j < _len1; _j++) {
      elt = _ref11[_j];
      element_type = this.element(elt.name);
      element = new element_type(elt.x, elt.y, elt.text, false);
      element._width = elt.width || null;
      element._height = elt.height || null;
      element._rotation = elt.rotation || 0;
      this.elements.push(element);
    }
    _ref12 = obj.links;
    for (_k = 0, _len2 = _ref12.length; _k < _len2; _k++) {
      lnk = _ref12[_k];
      link_type = this.link(lnk.name);
      link = new link_type(this.nodes()[lnk.source], this.nodes()[lnk.target], lnk.text);
      link.source_anchor = lnk.source_anchor;
      link.target_anchor = lnk.target_anchor;
      this.links.push(link);
    }
    if (obj.force) {
      return this.start_force();
    }
  };

  return Diagram;

})(Base);

Rect = (function(_super) {
  __extends(Rect, _super);

  function Rect() {
    _ref10 = Rect.__super__.constructor.apply(this, arguments);
    return _ref10;
  }

  Rect.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " " + (-h2) + "         L " + w2 + " " + (-h2) + "         L " + w2 + " " + h2 + "         L " + (-w2) + " " + h2 + "         z";
  };

  return Rect;

})(Element);

Ellipsis = (function(_super) {
  __extends(Ellipsis, _super);

  function Ellipsis() {
    _ref11 = Ellipsis.__super__.constructor.apply(this, arguments);
    return _ref11;
  }

  Ellipsis.prototype.txt_width = function() {
    return 2 * Ellipsis.__super__.txt_width.call(this) / Math.sqrt(2);
  };

  Ellipsis.prototype.txt_height = function() {
    return 2 * Ellipsis.__super__.txt_height.call(this) / Math.sqrt(2);
  };

  Ellipsis.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " 0         A " + w2 + " " + h2 + " 0 1 1 " + w2 + " 0         A " + w2 + " " + h2 + " 0 1 1 " + (-w2) + " 0        ";
  };

  return Ellipsis;

})(Element);

Note = (function(_super) {
  __extends(Note, _super);

  function Note() {
    _ref12 = Note.__super__.constructor.apply(this, arguments);
    return _ref12;
  }

  Note.prototype.shift = 15;

  Note.prototype.txt_width = function() {
    return Note.__super__.txt_width.call(this) + this.shift;
  };

  Note.prototype.txt_x = function() {
    return Note.__super__.txt_x.call(this) - this.shift / 2;
  };

  Note.prototype.txt_y = function() {
    return Note.__super__.txt_y.call(this);
  };

  Note.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " " + (-h2) + "         L " + (w2 - this.shift) + " " + (-h2) + "         L " + w2 + " " + (-h2 + this.shift) + "         L " + w2 + " " + h2 + "         L " + (-w2) + " " + h2 + "         L " + (-w2) + " " + (-h2 + this.shift) + "         z         M " + w2 + " " + (-h2 + this.shift) + "         L " + (w2 - this.shift) + " " + (-h2 + this.shift) + "         L " + (w2 - this.shift) + " " + (-h2) + "        ";
  };

  return Note;

})(Element);

Lozenge = (function(_super) {
  __extends(Lozenge, _super);

  function Lozenge() {
    _ref13 = Lozenge.__super__.constructor.apply(this, arguments);
    return _ref13;
  }

  Lozenge.prototype.txt_width = function() {
    var ow;
    ow = Lozenge.__super__.txt_width.call(this);
    return ow + Math.sqrt(ow * this["super"]('txt_height', Lozenge));
  };

  Lozenge.prototype.txt_height = function() {
    var oh;
    oh = Lozenge.__super__.txt_height.call(this);
    return oh + Math.sqrt(oh * this["super"]('txt_width', Lozenge));
  };

  Lozenge.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " 0         L 0 " + (-h2) + "         L " + w2 + " 0         L 0 " + h2 + "         z";
  };

  return Lozenge;

})(Element);

WhiteArrow = (function(_super) {
  __extends(WhiteArrow, _super);

  function WhiteArrow() {
    _ref14 = WhiteArrow.__super__.constructor.apply(this, arguments);
    return _ref14;
  }

  return WhiteArrow;

})(BlackArrow);

BlackDiamond = (function(_super) {
  __extends(BlackDiamond, _super);

  function BlackDiamond() {
    _ref15 = BlackDiamond.__super__.constructor.apply(this, arguments);
    return _ref15;
  }

  BlackDiamond.prototype.path = function() {
    return 'M 0 5 L 10 0 L 20 5 L 10 10 z';
  };

  return BlackDiamond;

})(Marker);

WhiteDiamond = (function(_super) {
  __extends(WhiteDiamond, _super);

  function WhiteDiamond() {
    _ref16 = WhiteDiamond.__super__.constructor.apply(this, arguments);
    return _ref16;
  }

  return WhiteDiamond;

})(BlackDiamond);

Association = (function(_super) {
  __extends(Association, _super);

  function Association() {
    _ref17 = Association.__super__.constructor.apply(this, arguments);
    return _ref17;
  }

  Association.marker = new BlackArrow();

  return Association;

})(Link);

Inheritance = (function(_super) {
  __extends(Inheritance, _super);

  function Inheritance() {
    _ref18 = Inheritance.__super__.constructor.apply(this, arguments);
    return _ref18;
  }

  Inheritance.marker = new WhiteArrow();

  return Inheritance;

})(Link);

Composition = (function(_super) {
  __extends(Composition, _super);

  function Composition() {
    _ref19 = Composition.__super__.constructor.apply(this, arguments);
    return _ref19;
  }

  Composition.marker = new BlackDiamond();

  return Composition;

})(Link);

Comment = (function(_super) {
  __extends(Comment, _super);

  function Comment() {
    _ref20 = Comment.__super__.constructor.apply(this, arguments);
    return _ref20;
  }

  Comment.marker = new Arrow();

  Comment.type = 'dashed';

  return Comment;

})(Link);

Aggregation = (function(_super) {
  __extends(Aggregation, _super);

  function Aggregation() {
    _ref21 = Aggregation.__super__.constructor.apply(this, arguments);
    return _ref21;
  }

  Aggregation.marker = new WhiteDiamond();

  return Aggregation;

})(Link);

uml_links = [Association, Inheritance, Aggregation, Composition, Comment];

uml_elements = [Note];

Group = (function(_super) {
  __extends(Group, _super);

  function Group() {
    _ref22 = Group.__super__.constructor.apply(this, arguments);
    return _ref22;
  }

  Group.prototype.contains = function(elt) {
    var h2, w2, _ref23, _ref24;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return (this.x - w2 < (_ref23 = elt.x) && _ref23 < this.x + w2) && (this.y - h2 < (_ref24 = elt.y) && _ref24 < this.y + h2);
  };

  Group.prototype.txt_y = function() {
    var lines;
    lines = this.text.split('\n').length;
    return this.margin.y - this.height() / 2 + this._txt_bbox.height - (this._txt_bbox.height * (lines - 1) / lines);
  };

  Group.prototype.path = function() {
    var h2, h2l, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    h2l = -h2 + this.txt_height() + this.margin.y;
    return "M " + (-w2) + " " + (-h2) + "         L " + w2 + " " + (-h2) + "         L " + w2 + " " + h2l + "         L " + (-w2) + " " + h2l + "         z         M " + w2 + " " + h2l + "         L " + w2 + " " + h2 + "         L " + (-w2) + " " + h2 + "         L " + (-w2) + " " + h2l + "        ";
  };

  return Group;

})(Element);

Box = (function(_super) {
  __extends(Box, _super);

  function Box() {
    _ref23 = Box.__super__.constructor.apply(this, arguments);
    return _ref23;
  }

  Box.rotationable = true;

  return Box;

})(Rect);

Polygon = (function(_super) {
  __extends(Polygon, _super);

  function Polygon() {
    _ref24 = Polygon.__super__.constructor.apply(this, arguments);
    return _ref24;
  }

  return Polygon;

})(Rect);

Ellipse = (function(_super) {
  __extends(Ellipse, _super);

  function Ellipse() {
    _ref25 = Ellipse.__super__.constructor.apply(this, arguments);
    return _ref25;
  }

  Ellipse.rotationable = true;

  return Ellipse;

})(Ellipsis);

Oval = (function(_super) {
  __extends(Oval, _super);

  function Oval() {
    _ref26 = Oval.__super__.constructor.apply(this, arguments);
    return _ref26;
  }

  return Oval;

})(Ellipse);

Diamond = (function(_super) {
  __extends(Diamond, _super);

  function Diamond() {
    _ref27 = Diamond.__super__.constructor.apply(this, arguments);
    return _ref27;
  }

  Diamond.rotationable = true;

  return Diamond;

})(Lozenge);

Note = (function(_super) {
  __extends(Note, _super);

  function Note() {
    _ref28 = Note.__super__.constructor.apply(this, arguments);
    return _ref28;
  }

  Note.rotationable = true;

  return Note;

})(Note);

NoneLink = (function(_super) {
  __extends(NoneLink, _super);

  function NoneLink() {
    _ref29 = NoneLink.__super__.constructor.apply(this, arguments);
    return _ref29;
  }

  return NoneLink;

})(Link);

CurveLink = (function(_super) {
  __extends(CurveLink, _super);

  function CurveLink() {
    _ref30 = CurveLink.__super__.constructor.apply(this, arguments);
    return _ref30;
  }

  CurveLink.marker = new Arrow();

  return CurveLink;

})(Link);

NormalLink = (function(_super) {
  __extends(NormalLink, _super);

  function NormalLink() {
    _ref31 = NormalLink.__super__.constructor.apply(this, arguments);
    return _ref31;
  }

  NormalLink.marker = new BlackArrow();

  return NormalLink;

})(Link);

OnormalLink = (function(_super) {
  __extends(OnormalLink, _super);

  function OnormalLink() {
    _ref32 = OnormalLink.__super__.constructor.apply(this, arguments);
    return _ref32;
  }

  OnormalLink.marker = new WhiteArrow();

  return OnormalLink;

})(Link);

DiamondLink = (function(_super) {
  __extends(DiamondLink, _super);

  function DiamondLink() {
    _ref33 = DiamondLink.__super__.constructor.apply(this, arguments);
    return _ref33;
  }

  DiamondLink.marker = new BlackDiamond();

  return DiamondLink;

})(Link);

OdiamondLink = (function(_super) {
  __extends(OdiamondLink, _super);

  function OdiamondLink() {
    _ref34 = OdiamondLink.__super__.constructor.apply(this, arguments);
    return _ref34;
  }

  OdiamondLink.marker = new WhiteDiamond();

  return OdiamondLink;

})(Link);

DotDiagram = (function(_super) {
  __extends(DotDiagram, _super);

  DotDiagram.prototype.label = 'Dot diagram';

  function DotDiagram() {
    DotDiagram.__super__.constructor.apply(this, arguments);
    this.linkstyle = new LinkStyles.Curve();
    this.types = {
      elements: [Box, Polygon, Ellipse, Oval, Diamond, Note],
      groups: [],
      links: [NoneLink, CurveLink, NormalLink, OnormalLink, DiamondLink, OdiamondLink]
    };
  }

  return DotDiagram;

})(Diagram);

Diagram.diagrams['DotDiagram'] = DotDiagram;

Process = (function(_super) {
  __extends(Process, _super);

  function Process() {
    _ref35 = Process.__super__.constructor.apply(this, arguments);
    return _ref35;
  }

  return Process;

})(Rect);

IO = (function(_super) {
  __extends(IO, _super);

  function IO() {
    var _this = this;
    IO.__super__.constructor.apply(this, arguments);
    this.anchors[cardinal.N] = function() {
      return {
        x: _this.x - _this.height() / 4,
        y: _this.y - _this.height() / 2
      };
    };
    this.anchors[cardinal.S] = function() {
      return {
        x: _this.x + _this.height() / 4,
        y: _this.y + _this.height() / 2
      };
    };
    this.anchors[cardinal.E] = function() {
      return {
        x: _this.x + _this.width() / 2 - _this.height() / 4,
        y: _this.y
      };
    };
    this.anchors[cardinal.W] = function() {
      return {
        x: _this.x - _this.width() / 2 + _this.height() / 4,
        y: _this.y
      };
    };
  }

  IO.prototype.txt_width = function() {
    return IO.__super__.txt_width.call(this) + this.height();
  };

  IO.prototype.path = function() {
    var h2, lw2, w2;
    w2 = (this.width() - this.height()) / 2;
    h2 = this.height() / 2;
    lw2 = this.width() / 2;
    return "M " + (-lw2) + " " + (-h2) + "         L " + w2 + " " + (-h2) + "         L " + lw2 + " " + h2 + "         L " + (-w2) + " " + h2 + "         z";
  };

  return IO;

})(Element);

Terminator = (function(_super) {
  __extends(Terminator, _super);

  function Terminator() {
    _ref36 = Terminator.__super__.constructor.apply(this, arguments);
    return _ref36;
  }

  Terminator.prototype.path = function() {
    var h2, shift, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    shift = Math.min(w2 / 2, h2 / 2);
    return "M " + (-w2 + shift) + " " + (-h2) + "         L " + (w2 - shift) + " " + (-h2) + "         Q " + w2 + " " + (-h2) + " " + w2 + " " + (-h2 + shift) + "         L " + w2 + " " + (h2 - shift) + "         Q " + w2 + " " + h2 + " " + (w2 - shift) + " " + h2 + "         L " + (-w2 + shift) + " " + h2 + "         Q " + (-w2) + " " + h2 + " " + (-w2) + " " + (h2 - shift) + "         L " + (-w2) + " " + (-h2 + shift) + "         Q " + (-w2) + " " + (-h2) + " " + (-w2 + shift) + " " + (-h2);
  };

  return Terminator;

})(Element);

Decision = (function(_super) {
  __extends(Decision, _super);

  function Decision() {
    Decision.__super__.constructor.apply(this, arguments);
    this.margin.x = 0;
    this.margin.y = 2;
  }

  return Decision;

})(Lozenge);

Delay = (function(_super) {
  __extends(Delay, _super);

  function Delay() {
    var _this = this;
    Delay.__super__.constructor.apply(this, arguments);
    this.anchors[cardinal.N] = function() {
      return {
        x: _this.x + _this.txt_x(),
        y: _this.y - _this.height() / 2
      };
    };
    this.anchors[cardinal.S] = function() {
      return {
        x: _this.x + _this.txt_x(),
        y: _this.y + _this.height() / 2
      };
    };
  }

  Delay.prototype.txt_x = function() {
    return Delay.__super__.txt_x.call(this) - this.height() / 4 + this.txt_height() / 6;
  };

  Delay.prototype.txt_width = function() {
    return Math.max(0, Delay.__super__.txt_width.call(this) - this.txt_height() / 3) + this.height() / 2;
  };

  Delay.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " " + (-h2) + "         L " + (w2 - h2) + " " + (-h2) + "         A " + h2 + " " + h2 + " 0 1 1 " + (w2 - h2) + " " + h2 + "         L " + (-w2) + " " + h2 + "         z";
  };

  return Delay;

})(Element);

SubProcess = (function(_super) {
  __extends(SubProcess, _super);

  function SubProcess() {
    _ref37 = SubProcess.__super__.constructor.apply(this, arguments);
    return _ref37;
  }

  SubProcess.prototype.shift = 1.2;

  SubProcess.prototype.txt_width = function() {
    return SubProcess.__super__.txt_width.call(this) * this.shift;
  };

  SubProcess.prototype.shift_width = function() {
    return this.width() * (this.shift - 1) / this.shift;
  };

  SubProcess.prototype.path = function() {
    var h2, lw2, w2;
    w2 = this.width() / 2;
    lw2 = w2 - this.shift_width() / 2;
    h2 = this.height() / 2;
    return "" + (SubProcess.__super__.path.call(this)) + "         M " + (-lw2) + " " + (-h2) + "         L " + (-lw2) + " " + h2 + "         M " + lw2 + " " + (-h2) + "         L " + lw2 + " " + h2 + "        ";
  };

  return SubProcess;

})(Process);

Document = (function(_super) {
  __extends(Document, _super);

  function Document() {
    _ref38 = Document.__super__.constructor.apply(this, arguments);
    return _ref38;
  }

  Document.prototype.txt_height = function() {
    return Document.__super__.txt_height.call(this) * 1.25;
  };

  Document.prototype.txt_y = function() {
    return Document.__super__.txt_y.call(this) - this.height() / 16;
  };

  Document.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " " + (-h2) + "         L " + w2 + " " + (-h2) + "         L " + w2 + " " + h2 + "         Q " + (w2 / 2) + " " + (h2 / 2) + " 0 " + h2 + "         T " + (-w2) + " " + h2 + "         z";
  };

  return Document;

})(Element);

Database = (function(_super) {
  __extends(Database, _super);

  function Database() {
    _ref39 = Database.__super__.constructor.apply(this, arguments);
    return _ref39;
  }

  Database.prototype.txt_y = function() {
    return Database.__super__.txt_y.call(this) + this.radius() / 2;
  };

  Database.prototype.txt_height = function() {
    return Database.__super__.txt_height.call(this) + 20;
  };

  Database.prototype.radius = function() {
    return Math.min((this.height() - this["super"]('txt_height')) / 4, this.width() / 3);
  };

  Database.prototype.path = function() {
    var h2, r, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    r = this.radius();
    return "M " + (-w2) + " " + (-h2 + r) + "         A " + w2 + " " + r + " 0 1 1 " + w2 + " " + (-h2 + r) + "         A " + w2 + " " + r + " 0 1 1 " + (-w2) + " " + (-h2 + r) + "         M " + w2 + " " + (-h2 + r) + "         L " + w2 + " " + (h2 - r) + "         A " + w2 + " " + r + " 0 1 1 " + (-w2) + " " + (h2 - r) + "         L " + (-w2) + " " + (-h2 + r);
  };

  return Database;

})(Element);

HardDisk = (function(_super) {
  __extends(HardDisk, _super);

  function HardDisk() {
    _ref40 = HardDisk.__super__.constructor.apply(this, arguments);
    return _ref40;
  }

  HardDisk.prototype.txt_x = function() {
    return HardDisk.__super__.txt_x.call(this) - this.radius() / 2;
  };

  HardDisk.prototype.txt_width = function() {
    return HardDisk.__super__.txt_width.call(this) + 20;
  };

  HardDisk.prototype.radius = function() {
    return Math.min((this.width() - this["super"]('txt_width')) / 4, this.height() / 3);
  };

  HardDisk.prototype.path = function() {
    var h2, r, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    r = this.radius();
    return "M " + (w2 - r) + " " + h2 + "         A " + r + " " + h2 + " 0 1 1 " + (w2 - r) + " " + (-h2) + "         A " + r + " " + h2 + " 0 1 1 " + (w2 - r) + " " + h2 + "         L " + (-w2 + r) + " " + h2 + "         A " + r + " " + h2 + " 0 1 1 " + (-w2 + r) + " " + (-h2) + "         L " + (w2 - r) + " " + (-h2) + "        ";
  };

  return HardDisk;

})(Element);

ManualInput = (function(_super) {
  __extends(ManualInput, _super);

  ManualInput.prototype.shift = 2;

  function ManualInput() {
    var _this = this;
    ManualInput.__super__.constructor.apply(this, arguments);
    this.anchors[cardinal.N] = function() {
      return {
        x: _this.x,
        y: _this.y - _this.shift_height() / 2
      };
    };
    this.anchors[cardinal.W] = function() {
      return {
        x: _this.x - _this.width() / 2,
        y: _this.y + _this.shift_height() / 2
      };
    };
  }

  ManualInput.prototype.shift_height = function() {
    return this.height() * (this.shift - 1) / this.shift;
  };

  ManualInput.prototype.txt_height = function() {
    return ManualInput.__super__.txt_height.call(this) * this.shift;
  };

  ManualInput.prototype.txt_y = function() {
    return ManualInput.__super__.txt_y.call(this) + this.shift_height() / 2;
  };

  ManualInput.prototype.path = function() {
    var h2, th2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    th2 = h2 - this.shift_height();
    return "M " + (-w2) + " " + (-th2) + "          L " + w2 + " " + (-h2) + "          L " + w2 + " " + h2 + "          L " + (-w2) + " " + h2 + "          z";
  };

  return ManualInput;

})(Element);

Preparation = (function(_super) {
  __extends(Preparation, _super);

  function Preparation() {
    _ref41 = Preparation.__super__.constructor.apply(this, arguments);
    return _ref41;
  }

  Preparation.prototype.shift = 1.25;

  Preparation.prototype.txt_width = function() {
    return Preparation.__super__.txt_width.call(this) * this.shift;
  };

  Preparation.prototype.shift_width = function() {
    return this.width() * (this.shift - 1) / this.shift;
  };

  Preparation.prototype.path = function() {
    var h2, lw2, w2;
    w2 = this.width() / 2;
    lw2 = w2 - this.shift_width() / 2;
    h2 = this.height() / 2;
    return "M " + (-w2) + " 0         L " + (-lw2) + " " + (-h2) + "         L " + lw2 + " " + (-h2) + "         L " + w2 + " 0         L " + lw2 + " " + h2 + "         L " + (-lw2) + " " + h2 + "         z";
  };

  return Preparation;

})(Element);

InternalStorage = (function(_super) {
  __extends(InternalStorage, _super);

  function InternalStorage() {
    _ref42 = InternalStorage.__super__.constructor.apply(this, arguments);
    return _ref42;
  }

  InternalStorage.prototype.hshift = 1.5;

  InternalStorage.prototype.wshift = 1.1;

  InternalStorage.prototype.txt_x = function() {
    return InternalStorage.__super__.txt_x.call(this) + this.shift_width() / 2;
  };

  InternalStorage.prototype.txt_y = function() {
    return InternalStorage.__super__.txt_y.call(this) + this.shift_height() / 2;
  };

  InternalStorage.prototype.txt_width = function() {
    return InternalStorage.__super__.txt_width.call(this) * this.wshift;
  };

  InternalStorage.prototype.txt_height = function() {
    return InternalStorage.__super__.txt_height.call(this) * this.hshift;
  };

  InternalStorage.prototype.shift_width = function() {
    return this.width() * (this.wshift - 1) / this.wshift;
  };

  InternalStorage.prototype.shift_height = function() {
    return this.height() * (this.hshift - 1) / this.hshift;
  };

  InternalStorage.prototype.path = function() {
    var h2, lh2, lw2, w2;
    w2 = this.width() / 2;
    lw2 = w2 - this.shift_width();
    h2 = this.height() / 2;
    lh2 = h2 - this.shift_height();
    return "" + (InternalStorage.__super__.path.call(this)) + "         M " + (-lw2) + " " + (-h2) + "         L " + (-lw2) + " " + h2 + "         M " + (-w2) + " " + (-lh2) + "         L " + w2 + " " + (-lh2) + "        ";
  };

  return InternalStorage;

})(Process);

Flow = (function(_super) {
  __extends(Flow, _super);

  function Flow() {
    _ref43 = Flow.__super__.constructor.apply(this, arguments);
    return _ref43;
  }

  Flow.marker = new BlackArrow();

  return Flow;

})(Link);

Container = (function(_super) {
  __extends(Container, _super);

  function Container() {
    _ref44 = Container.__super__.constructor.apply(this, arguments);
    return _ref44;
  }

  return Container;

})(Group);

FlowChart = (function(_super) {
  __extends(FlowChart, _super);

  FlowChart.prototype.label = 'Flow Chart';

  function FlowChart() {
    FlowChart.__super__.constructor.call(this);
    this.types = {
      elements: [Process, IO, Terminator, Decision, Delay, SubProcess, Document, Database, HardDisk, ManualInput, Preparation, InternalStorage],
      groups: [Container],
      links: [Flow]
    };
  }

  return FlowChart;

})(Diagram);

Diagram.diagrams['FlowChart'] = FlowChart;

Case = (function(_super) {
  __extends(Case, _super);

  function Case() {
    _ref45 = Case.__super__.constructor.apply(this, arguments);
    return _ref45;
  }

  return Case;

})(Ellipsis);

Actor = (function(_super) {
  __extends(Actor, _super);

  function Actor() {
    var _this = this;
    Actor.__super__.constructor.apply(this, arguments);
    this.anchors[cardinal.E] = function() {
      return {
        x: _this.x + (_this.width() - _this["super"]('txt_width')) / 2,
        y: _this.y
      };
    };
    this.anchors[cardinal.W] = function() {
      return {
        x: _this.x - (_this.width() - _this["super"]('txt_width')) / 2,
        y: _this.y
      };
    };
  }

  Actor.prototype.txt_y = function() {
    return this.height() / 2 - this["super"]('txt_height') + 2 + 4 * this.margin.y;
  };

  Actor.prototype.txt_height = function() {
    return Actor.__super__.txt_height.call(this) + 50;
  };

  Actor.prototype.txt_width = function() {
    return Actor.__super__.txt_width.call(this) + 25;
  };

  Actor.prototype.path = function() {
    var bottom, hstick, wstick;
    wstick = (this.width() - this["super"]('txt_width')) / 2;
    hstick = (this.height() - this["super"]('txt_height')) / 4;
    bottom = this.txt_y() - 4 * this.margin.y;
    return "M " + (-wstick) + " " + bottom + "         L 0 " + (bottom - hstick) + "         M " + wstick + " " + bottom + "         L 0 " + (bottom - hstick) + "         M 0 " + (bottom - hstick) + "         L 0 " + (bottom - 2 * hstick) + "         M " + (-wstick) + " " + (bottom - 1.75 * hstick) + "         L " + wstick + " " + (bottom - 2.25 * hstick) + "         M 0 " + (bottom - 2 * hstick) + "         L 0 " + (bottom - 3 * hstick) + "         A " + (.5 * wstick) + " " + (.5 * hstick) + " 0 1 1 0 " + (bottom - 4 * hstick) + "         A " + (.5 * wstick) + " " + (.5 * hstick) + " 0 1 1 0 " + (bottom - 3 * hstick) + "         ";
  };

  return Actor;

})(Element);

System = (function(_super) {
  __extends(System, _super);

  function System() {
    _ref46 = System.__super__.constructor.apply(this, arguments);
    return _ref46;
  }

  return System;

})(Group);

UseCase = (function(_super) {
  __extends(UseCase, _super);

  UseCase.prototype.label = 'UML Use Case Diagram';

  function UseCase() {
    UseCase.__super__.constructor.apply(this, arguments);
    this.linkstyle = new LinkStyles.Diagonal();
    this.types = {
      elements: [Actor, Case],
      groups: [System],
      links: uml_links
    };
  }

  return UseCase;

})(Diagram);

Diagram.diagrams['UseCase'] = UseCase;

Electric = (function(_super) {
  __extends(Electric, _super);

  function Electric() {
    _ref47 = Electric.__super__.constructor.apply(this, arguments);
    return _ref47;
  }

  Electric.resizeable = false;

  Electric.rotationable = true;

  Electric.prototype.anchor_list = function() {
    return [cardinal.W, cardinal.E];
  };

  Electric.prototype.base_height = function() {
    return 20;
  };

  Electric.prototype._base_width = function() {
    return 20;
  };

  Electric.prototype.base_width = function() {
    return this._base_width() + 2 * this.wire_margin();
  };

  Electric.prototype.wire_margin = function() {
    return 10;
  };

  Electric.prototype.txt_y = function() {
    return this.height() / 2 + 3 * this.margin.y;
  };

  Electric.prototype.txt_height = function() {
    return this.base_height();
  };

  Electric.prototype.txt_width = function() {
    return this.base_width();
  };

  return Electric;

})(Element);

Junction = (function(_super) {
  __extends(Junction, _super);

  Junction.fill = 'fg';

  function Junction() {
    Junction.__super__.constructor.apply(this, arguments);
    this.margin.x = 0;
    this.margin.y = 0;
    this.text = '';
  }

  Junction.prototype.base_width = function() {
    return this._base_width() / 4;
  };

  Junction.prototype.base_height = function() {
    return Junction.__super__.base_height.call(this) / 4;
  };

  Junction.prototype.anchor_list = function() {
    return [cardinal.N, cardinal.S, cardinal.W, cardinal.E];
  };

  Junction.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "M 0 " + (-h2) + "         A " + w2 + " " + h2 + " 0 0 1 0 " + h2 + "         A " + w2 + " " + h2 + " 0 0 1 0 " + (-h2) + "            ";
  };

  return Junction;

})(Electric);

Resistor = (function(_super) {
  __extends(Resistor, _super);

  function Resistor() {
    _ref48 = Resistor.__super__.constructor.apply(this, arguments);
    return _ref48;
  }

  Resistor.fill = 'none';

  Resistor.prototype._base_width = function() {
    return Resistor.__super__._base_width.call(this) * 3;
  };

  Resistor.prototype.path = function() {
    var h2, lw2, path, w, w2, _i;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    lw2 = w2 - this.wire_margin();
    path = "M " + (-w2) + " 0                L " + (-lw2) + " 0";
    for (w = _i = -3; _i <= 2; w = ++_i) {
      path = "" + path + " L " + (lw2 * w / 3 + lw2 / 6) + " " + (h2 * (w % 2 ? -1 : 1));
    }
    return "" + path + "         L " + lw2 + " 0         L " + w2 + " 0";
  };

  return Resistor;

})(Electric);

Diode = (function(_super) {
  __extends(Diode, _super);

  function Diode() {
    _ref49 = Diode.__super__.constructor.apply(this, arguments);
    return _ref49;
  }

  Diode.prototype.path = function() {
    var h2, lw2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    lw2 = w2 - this.wire_margin();
    return "M " + (-w2) + " 0         L " + (-lw2) + " 0         M " + (-lw2) + " " + (-h2) + "         L " + lw2 + " 0         L " + lw2 + " " + (-h2) + "         L " + lw2 + " " + h2 + "         L " + lw2 + " 0         L " + (-lw2) + " " + h2 + "        z         M " + lw2 + " 0         L " + w2 + " 0        ";
  };

  return Diode;

})(Electric);

Battery = (function(_super) {
  __extends(Battery, _super);

  function Battery() {
    _ref50 = Battery.__super__.constructor.apply(this, arguments);
    return _ref50;
  }

  Battery.fill = 'fg';

  Battery.prototype._base_width = function() {
    return Battery.__super__._base_width.call(this) / 3;
  };

  Battery.prototype.base_height = function() {
    return Battery.__super__.base_height.call(this) * 2;
  };

  Battery.prototype.path = function() {
    var h2, h4, lw2, lw4, w2;
    w2 = this.width() / 2;
    lw2 = w2 - this.wire_margin();
    lw4 = lw2 / 2;
    h2 = this.height() / 2;
    h4 = h2 / 2;
    return "M " + (-w2) + " 0         L " + (-lw2) + " 0         M " + (-lw2) + " " + (-h4) + "         L " + (-lw4) + " " + (-h4) + "         L " + (-lw4) + " " + h4 + "         L " + (-lw2) + " " + h4 + "         z         M " + lw2 + " " + (-h2) + "         L " + lw2 + " " + h2 + "         M " + lw2 + " 0         L " + w2 + " 0        ";
  };

  return Battery;

})(Electric);

Transistor = (function(_super) {
  __extends(Transistor, _super);

  function Transistor() {
    var _this = this;
    Transistor.__super__.constructor.apply(this, arguments);
    this.anchors[cardinal.N] = function() {
      return {
        x: _this.x + (_this.width() / 2 - _this.wire_margin()) * .6,
        y: _this.y - _this.height() / 2
      };
    };
    this.anchors[cardinal.S] = function() {
      return {
        x: _this.x + (_this.width() / 2 - _this.wire_margin()) * .6,
        y: _this.y + _this.height() / 2
      };
    };
  }

  Transistor.prototype.base_width = function() {
    return 2 * this._base_width() + 2 * this.wire_margin();
  };

  Transistor.prototype.base_height = function() {
    return 2 * Transistor.__super__.base_height.call(this) + 2 * this.wire_margin();
  };

  Transistor.prototype.anchor_list = function() {
    return [cardinal.W, cardinal.N, cardinal.S];
  };

  Transistor.prototype.wire_margin = function() {
    return Transistor.__super__.wire_margin.call(this);
  };

  Transistor.prototype.path = function() {
    var h2, hI, hv, hw, lh2, lw2, w2, wI, ww;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    lw2 = w2 - this.wire_margin();
    lh2 = h2 - this.wire_margin();
    wI = lw2 / 4;
    hI = lh2 * .6;
    hv = hI / 2;
    ww = lw2 * .6;
    hw = lh2 * .8;
    return "         M " + (-w2) + " 0         L " + (-lw2) + " 0         A " + lw2 + " " + lw2 + " 0 1 1 " + lw2 + " 0         A " + lw2 + " " + lw2 + " 0 1 1 " + (-lw2) + " 0         L " + (-wI) + " 0         M " + (-wI) + " " + (-hI) + "         L " + (-wI) + " " + hI + "         M " + (-wI) + " " + (-hv) + "         L " + ww + " " + (-hw) + "         M " + ww + " " + (-hw) + "         L " + ww + " " + (-h2) + "         M " + (-wI) + " " + hv + "         L " + ww + " " + hw + "         L " + ww + " " + h2 + "        ";
  };

  return Transistor;

})(Electric);

PNPTransistor = (function(_super) {
  __extends(PNPTransistor, _super);

  function PNPTransistor() {
    _ref51 = PNPTransistor.__super__.constructor.apply(this, arguments);
    return _ref51;
  }

  PNPTransistor.prototype.path = function() {
    var h2, ha, hb, hw, lh2, lw2, w2, wa, wb, ww;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    lw2 = w2 - this.wire_margin();
    lh2 = h2 - this.wire_margin();
    ww = lw2 * .6;
    hw = lh2 * .8;
    wa = lw2 * .1;
    ha = lh2 * .7;
    wb = lw2 * .3;
    hb = lh2 * .4;
    return "" + (PNPTransistor.__super__.path.call(this)) + "        M " + ww + " " + (-hw) + "        L " + wa + " " + (-ha) + "        M " + ww + " " + (-hw) + "        L " + wb + " " + (-hb) + "        ";
  };

  return PNPTransistor;

})(Transistor);

NPNTransistor = (function(_super) {
  __extends(NPNTransistor, _super);

  function NPNTransistor() {
    _ref52 = NPNTransistor.__super__.constructor.apply(this, arguments);
    return _ref52;
  }

  NPNTransistor.prototype.path = function() {
    var h2, ha, hb, hw, lh2, lw2, w2, wa, wb, ww;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    lw2 = w2 - this.wire_margin();
    lh2 = h2 - this.wire_margin();
    ww = lw2 * .6;
    hw = lh2 * .8;
    wa = lw2 * .1;
    ha = lh2 * .7;
    wb = lw2 * .3;
    hb = lh2 * .4;
    return "" + (NPNTransistor.__super__.path.call(this)) + "        M " + ww + " " + hw + "        L " + wa + " " + ha + "        M " + ww + " " + hw + "        L " + wb + " " + hb + "        ";
  };

  return NPNTransistor;

})(Transistor);

Wire = (function(_super) {
  __extends(Wire, _super);

  function Wire() {
    _ref53 = Wire.__super__.constructor.apply(this, arguments);
    return _ref53;
  }

  return Wire;

})(Link);

ElectricDiagram = (function(_super) {
  __extends(ElectricDiagram, _super);

  ElectricDiagram.prototype.label = 'Electric Diagram';

  function ElectricDiagram() {
    ElectricDiagram.__super__.constructor.apply(this, arguments);
    this.linkstyle = new LinkStyles.Rectangular();
    this.snap.a = 90;
    this.types = {
      elements: [Diode, Resistor, Junction, Battery, NPNTransistor, PNPTransistor],
      groups: [],
      links: [Wire]
    };
  }

  return ElectricDiagram;

})(Diagram);

Diagram.diagrams['ElectricDiagram'] = ElectricDiagram;

Class = (function(_super) {
  __extends(Class, _super);

  function Class() {
    _ref54 = Class.__super__.constructor.apply(this, arguments);
    return _ref54;
  }

  Class.prototype.shift = 10;

  Class.prototype.height = function() {
    return Class.__super__.height.call(this) + this.shift * 2;
  };

  Class.prototype.txt_y = function() {
    return Class.__super__.txt_y.call(this) - this.shift;
  };

  Class.prototype.path = function() {
    var h2, w2;
    w2 = this.width() / 2;
    h2 = this.height() / 2;
    return "" + (Class.__super__.path.call(this)) + "         M " + (-w2) + " " + (h2 - this.shift) + "         L " + w2 + " " + (h2 - this.shift) + "         M " + (-w2) + " " + (h2 - 2 * this.shift) + "         L " + w2 + " " + (h2 - 2 * this.shift) + "        ";
  };

  return Class;

})(Rect);

ClassDiagram = (function(_super) {
  __extends(ClassDiagram, _super);

  ClassDiagram.prototype.label = 'UML Class Diagram';

  function ClassDiagram() {
    ClassDiagram.__super__.constructor.apply(this, arguments);
    this.linkstyle = new LinkStyles.Diagonal();
    this.types = {
      elements: [Class].concat(uml_elements),
      groups: [System],
      links: uml_links
    };
  }

  return ClassDiagram;

})(Diagram);

Diagram.diagrams['ClassDiagram'] = ClassDiagram;

order = function(a, b) {
  return d3.ascending(a.ts, b.ts);
};

node_add = function(type) {
  var dom_node, mouse_evt, new_node, nth, set, x, y;
  x = diagram.mouse.x;
  y = diagram.mouse.y;
  if (new type() instanceof Group) {
    set = diagram.groups;
    diagram.last_types.group = type;
  } else {
    set = diagram.elements;
    diagram.last_types.element = type;
  }
  nth = set.filter(function(node) {
    return node instanceof type;
  }).length + 1;
  new_node = new type(x, y, "" + type.name + " #" + nth, !diagram.force);
  set.push(new_node);
  if (d3.event) {
    diagram.selection = [new_node];
  }
  svg.sync(true);
  if (d3.event) {
    dom_node = null;
    svg.svg.selectAll('g.node').each(function(node) {
      if (node === new_node) {
        return dom_node = this;
      }
    });
    mouse_evt = document.createEvent('MouseEvent');
    mouse_evt.initMouseEvent(d3.event.type, d3.event.canBubble, d3.event.cancelable, d3.event.view, d3.event.detail, d3.event.screenX, d3.event.screenY, d3.event.clientX, d3.event.clientY, d3.event.ctrlKey, d3.event.altKey, d3.event.shiftKey, d3.event.metaKey, d3.event.button, d3.event.relatedTarget);
    return dom_node.dispatchEvent(mouse_evt);
  }
};

last_command = {
  fun: null,
  args: null
};

wrap = function(fun) {
  return function() {
    last_command = {
      fun: fun,
      args: arguments
    };
    return fun.apply(arguments);
  };
};

commands = {
  undo: {
    fun: function(e) {
      history.go(-1);
      return e != null ? e.preventDefault() : void 0;
    },
    label: 'Undo',
    glyph: 'chevron-left',
    hotkey: 'ctrl+z'
  },
  redo: {
    fun: function(e) {
      history.go(1);
      return e != null ? e.preventDefault() : void 0;
    },
    label: 'Redo',
    glyph: 'chevron-right',
    hotkey: 'ctrl+y'
  },
  save: {
    fun: function(e) {
      svg.sync(true);
      save();
      return e != null ? e.preventDefault() : void 0;
    },
    label: 'Save locally',
    glyph: 'save',
    hotkey: 'ctrl+s'
  },
  "export": {
    fun: function(e) {
      return location.href = "data:image/svg+xml;base64," + (btoa(diagram.to_svg()));
    },
    label: 'Export to svg',
    glyph: 'export',
    hotkey: 'ctrl+enter'
  },
  export_to_textile: {
    fun: function(e) {
      return edit((function() {
        return ("!data:image/svg+xml;base64," + (btoa(diagram.to_svg())) + "!:http://kozea.github.io/umlaut/#") + location.hash;
      }), (function() {
        return null;
      }));
    },
    hotkey: 'ctrl+b'
  },
  edit: {
    fun: function() {
      return edit((function() {
        if (diagram.selection.length === 1) {
          return diagram.selection[0].text;
        } else {
          return '';
        }
      }), (function(txt) {
        var node, _i, _len, _ref55, _results;
        _ref55 = diagram.selection;
        _results = [];
        for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
          node = _ref55[_i];
          _results.push(node.text = txt);
        }
        return _results;
      }));
    },
    label: 'Edit elements text',
    glyph: 'edit',
    hotkey: 'e'
  },
  remove: {
    fun: function() {
      var lnk, node, _i, _j, _len, _len1, _ref55, _ref56;
      _ref55 = diagram.selection;
      for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
        node = _ref55[_i];
        if (__indexOf.call(diagram.groups, node) >= 0) {
          diagram.groups.splice(diagram.groups.indexOf(node), 1);
        } else if (__indexOf.call(diagram.elements, node) >= 0) {
          diagram.elements.splice(diagram.elements.indexOf(node), 1);
        } else if (__indexOf.call(diagram.links, node) >= 0) {
          diagram.links.splice(diagram.links.indexOf(node), 1);
        }
        _ref56 = diagram.links.slice();
        for (_j = 0, _len1 = _ref56.length; _j < _len1; _j++) {
          lnk = _ref56[_j];
          if (node === lnk.source || node === lnk.target) {
            diagram.links.splice(diagram.links.indexOf(lnk), 1);
          }
        }
      }
      diagram.selection = [];
      return svg.sync(true);
    },
    label: 'Remove elements',
    glyph: 'remove-sign',
    hotkey: 'del'
  },
  select_all: {
    fun: function(e) {
      diagram.selection = diagram.nodes().concat(diagram.links);
      svg.tick();
      return e != null ? e.preventDefault() : void 0;
    },
    label: 'Select all elements',
    glyph: 'fullscreen',
    hotkey: 'ctrl+a'
  },
  force: {
    fun: function(e) {
      if (diagram.force) {
        diagram.force.stop();
        diagram.force = null;
        return;
      }
      diagram.start_force();
      return e != null ? e.preventDefault() : void 0;
    },
    label: 'Toggle force',
    glyph: 'send',
    hotkey: 'tab'
  },
  linkstyle: {
    fun: function() {
      diagram.linkstyle = new LinkStyles[next(LinkStyles, diagram.linkstyle.cls.name)]();
      return svg.tick();
    },
    label: 'Change link style',
    glyph: 'retweet',
    hotkey: 'space'
  },
  defaultscale: {
    fun: function() {
      diagram.zoom.scale = 1;
      diagram.zoom.translate = [0, 0];
      return svg.sync(true);
    },
    label: 'Reset view',
    glyph: 'screenshot',
    hotkey: 'ctrl+backspace'
  },
  snaptogrid: {
    fun: function() {
      var node, _i, _len, _ref55;
      _ref55 = diagram.nodes();
      for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
        node = _ref55[_i];
        node.x = node.px = diagram.snap.x * Math.floor(node.x / diagram.snap.x);
        node.y = node.py = diagram.snap.y * Math.floor(node.y / diagram.snap.y);
      }
      return svg.tick();
    },
    label: 'Snap to grid',
    glyph: 'magnet',
    hotkey: 'ctrl+space'
  },
  "switch": {
    fun: function() {
      var link, node, _i, _j, _len, _len1, _ref55, _ref56, _ref57, _ref58;
      _ref55 = diagram.selection;
      for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
        node = _ref55[_i];
        if (node instanceof Link) {
          _ref56 = [node.target, node.source], node.source = _ref56[0], node.target = _ref56[1];
        }
        if (node instanceof Element) {
          _ref57 = diagram.links;
          for (_j = 0, _len1 = _ref57.length; _j < _len1; _j++) {
            link = _ref57[_j];
            _ref58 = [link.target, link.source], link.source = _ref58[0], link.target = _ref58[1];
          }
        }
      }
      return svg.tick();
    },
    label: 'Switch link direction',
    glyph: 'transfer',
    hotkey: 'w'
  },
  back_to_list: {
    fun: function() {
      return location.href = '#';
    },
    label: 'Go back to diagram list',
    glyph: 'list',
    hotkey: 'esc'
  }
};

$(function() {
  var button, command, name;
  for (name in commands) {
    command = commands[name];
    if (command.glyph) {
      button = d3.select('.btns').append('button').attr('title', "" + command.label + " [" + command.hotkey + "]").attr('class', 'btn btn-default btn-sm').on('click', command.fun).append('span').attr('class', "glyphicon glyphicon-" + command.glyph);
    }
    Mousetrap.bind(command.hotkey, wrap(command.fun));
  }
  return Mousetrap.bind('z', function() {
    return last_command.fun.apply(last_command.args);
  });
});

init_commands = function() {
  var conf, e, e1, e2, element, fun, hotkey, i, icon, inc, key, l, link, margin, n, svgicon, taken_hotkeys, val, way, _i, _j, _len, _len1, _ref55, _ref56, _ref57, _ref58, _results;
  _ref55 = diagram.force_conf;
  for (conf in _ref55) {
    val = _ref55[conf];
    _ref56 = {
      increase: 1.1,
      decrease: 0.9
    };
    for (way in _ref56) {
      inc = _ref56[way];
      Mousetrap.bind("f " + conf[0] + " " + (way === 'increase' ? '+' : '-'), (function(c, i) {
        return wrap(function(e) {
          if (diagram.force) {
            diagram.force_conf[c] *= i;
          }
          return diagram.start_force();
        });
      })(conf, inc));
    }
  }
  taken_hotkeys = [];
  $('aside .icons .specific').each(function() {
    return Mousetrap.unbind($(this).attr('data-hotkey'));
  });
  $('aside .icons svg').remove();
  $('aside h3').attr('id', diagram.cls.name).addClass('specific').text(diagram.label);
  _ref57 = diagram.types.elements.concat(diagram.types.groups);
  for (_i = 0, _len = _ref57.length; _i < _len; _i++) {
    e = _ref57[_i];
    i = 1;
    key = e.name[0].toLowerCase();
    while (i < e.length && __indexOf.call(taken_hotkeys, key) >= 0) {
      key = e[i++].toLowerCase();
    }
    taken_hotkeys.push(key);
    fun = (function(node) {
      return function() {
        return node_add(node);
      };
    })(e);
    hotkey = "a " + key;
    icon = new e(0, 0, e.name);
    if (icon instanceof Group) {
      icon._height = 70;
      icon._width = 90;
    }
    svgicon = d3.select('aside .icons').append('svg').attr('class', 'icon specific draggable btn btn-default').attr('title', "" + e.name + " [" + hotkey + "]").attr('data-hotkey', hotkey).on('mousedown', fun);
    element = svgicon.selectAll(icon instanceof Group ? 'g.group' : 'g.element').data([icon]);
    element.enter().call(enter_node);
    element.call(update_node);
    margin = 3;
    svgicon.attr('viewBox', "                " + (-icon.width() / 2 - margin) + "                " + (-icon.height() / 2 - margin) + "                " + (icon.width() + 2 * margin) + "                " + (icon.height() + 2 * margin)).attr('width', icon.width()).attr('height', icon.height()).attr('preserveAspectRatio', 'xMidYMid meet');
    Mousetrap.bind(hotkey, wrap(fun));
  }
  taken_hotkeys = [];
  _ref58 = diagram.types.links;
  _results = [];
  for (n = _j = 0, _len1 = _ref58.length; _j < _len1; n = ++_j) {
    l = _ref58[n];
    i = 1;
    key = l.name[0].toLowerCase();
    while (i < l.length && __indexOf.call(taken_hotkeys, key) >= 0) {
      key = l[i++].toLowerCase();
    }
    taken_hotkeys.push(key);
    hotkey = "l " + key;
    icon = new l(e1 = new Element(0, 0), e2 = new Element(100, 0));
    e1.set_txt_bbox({
      width: 10,
      height: 10
    });
    e2.set_txt_bbox({
      width: 10,
      height: 10
    });
    svgicon = d3.select('aside .icons').append('svg').attr('class', "icon specific btn btn-default link " + l.name).attr('title', "" + l.name + " [" + hotkey + "]").attr('data-hotkey', hotkey).classed('active', n === 0).on('mousedown', (function(lnk) {
      return function() {
        diagram.last_types.link = lnk;
        d3.selectAll('aside .icons .link').classed('active', false);
        return d3.select(this).classed('active', true);
      };
    })(l));
    link = svgicon.selectAll('g.link').data([icon]);
    link.enter().call(enter_link, false);
    link.call(update_link);
    link.call(tick_link);
    svgicon.attr('height', 20).attr('viewBox', "0 -10 100 20").attr('preserveAspectRatio', 'none');
    _results.push(Mousetrap.bind(hotkey, wrap(fun)));
  }
  return _results;
};

edit = function(getter, setter) {
  var overlay, textarea, textarea_node;
  overlay = d3.select('#overlay').classed('visible', true);
  textarea = overlay.select('textarea');
  textarea_node = textarea.node();
  textarea.on('input', function() {
    var val;
    setter(((function() {
      var _i, _len, _ref55, _results;
      _ref55 = this.value.split('\n');
      _results = [];
      for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
        val = _ref55[_i];
        _results.push(val || ' ');
      }
      return _results;
    }).call(this)).join('\n'));
    return svg.sync();
  }).on('keydown', function() {
    if (d3.event.keyCode === 27) {
      textarea.on('input', null);
      textarea.on('keydown', null);
      textarea_node.value = '';
      overlay.classed('visible', false);
      return svg.sync(true);
    }
  });
  textarea_node.value = getter();
  textarea_node.select();
  textarea_node.focus();
  return overlay.on('click', function() {
    if (d3.event.target === this) {
      textarea.on('input', null);
      textarea.on('keydown', null);
      textarea_node.value = '';
      return overlay.classed('visible', false);
    }
  });
};

move_drag = d3.behavior.drag().on('dragstart', function(node) {
  if (d3.event.sourceEvent.which === !1 || d3.event.sourceEvent.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', true);
  svg.svg.classed('translating', true);
  return diagram.dragging = true;
}).on("drag", function(node) {
  var delta, x, y, _i, _j, _len, _len1, _ref55, _ref56, _ref57;
  if (!diagram.dragging || d3.event.sourceEvent.ctrlKey) {
    return;
  }
  x = diagram.force ? 'px' : 'x';
  y = diagram.force ? 'py' : 'y';
  if (_ref55 = !node, __indexOf.call(diagram.selection, _ref55) >= 0) {
    diagram.selection.push(node);
  }
  _ref56 = diagram.selection;
  for (_i = 0, _len = _ref56.length; _i < _len; _i++) {
    node = _ref56[_i];
    node.fixed = true;
  }
  if (d3.event.sourceEvent.shiftKey) {
    delta = {
      x: node[x] - d3.event.x,
      y: node[y] - d3.event.y
    };
  } else {
    delta = {
      x: node[x] - diagram.snap.x * Math.floor(d3.event.x / diagram.snap.x),
      y: node[y] - diagram.snap.y * Math.floor(d3.event.y / diagram.snap.y)
    };
  }
  _ref57 = diagram.selection;
  for (_j = 0, _len1 = _ref57.length; _j < _len1; _j++) {
    node = _ref57[_j];
    node[x] -= delta.x;
    node[y] -= delta.y;
  }
  if (diagram.force) {
    return diagram.force.resume();
  } else {
    return svg.tick();
  }
}).on('dragend', function(node) {
  var lnk, _i, _j, _len, _len1, _ref55, _ref56;
  svg.svg.classed('dragging', false);
  svg.svg.classed('translating', false);
  if (!diagram.dragging) {
    return;
  }
  _ref55 = diagram.nodes();
  for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
    node = _ref55[_i];
    node.fixed = false;
  }
  diagram.dragging = false;
  if (!$(d3.event.sourceEvent.target).closest('.inside').size()) {
    if (__indexOf.call(diagram.elements, node) >= 0) {
      diagram.elements.splice(diagram.elements.indexOf(node), 1);
    }
    if (__indexOf.call(diagram.groups, node) >= 0) {
      diagram.groups.splice(diagram.groups.indexOf(node), 1);
    }
    if (__indexOf.call(diagram.selection, node) >= 0) {
      diagram.selection.splice(diagram.selection.indexOf(node), 1);
    }
    _ref56 = diagram.links.slice();
    for (_j = 0, _len1 = _ref56.length; _j < _len1; _j++) {
      lnk = _ref56[_j];
      if (node === lnk.source || node === lnk.target) {
        diagram.links.splice(diagram.links.indexOf(lnk), 1);
      }
    }
  }
  return svg.sync(true);
});

nsweo_resize_drag = d3.behavior.drag().on("dragstart", function(handle) {
  var node;
  if (d3.event.sourceEvent.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', true);
  svg.svg.classed('resizing', true);
  node = d3.select($(this).closest('.node').get(0)).data()[0];
  diagram._origin = mouse_xy(svg.svg.node());
  node.ox = node.x;
  node.oy = node.y;
  node.owidth = node.width();
  node.oheight = node.height();
  node.fixed = true;
  return d3.event.sourceEvent.stopPropagation();
}).on("drag", function(handle) {
  var angle, delta, m, node, nodes, shift, signs, x, y;
  if (d3.event.ctrlKey) {
    return;
  }
  nodes = d3.select($(this).closest('.node').get(0));
  node = nodes.data()[0];
  m = mouse_xy(svg.svg.node());
  if (handle === 'O') {
    delta = {
      x: m.x - node.x,
      y: m.y - node.y
    };
    angle = atan2(delta.y, delta.x) + pi / 2;
    if (!d3.event.sourceEvent.shiftKey) {
      angle = to_rad(diagram.snap.a * Math.floor(to_deg(angle) / diagram.snap.a));
    }
    node._rotation = angle;
  } else {
    delta = {
      x: m.x - diagram._origin.x,
      y: m.y - diagram._origin.y
    };
    delta = rotate(delta, 2 * pi - node._rotation);
    x = diagram.force ? 'px' : 'x';
    y = diagram.force ? 'py' : 'y';
    signs = cardinal_to_direction(handle);
    node.width(node.owidth + signs.x * delta.x);
    node.height(node.oheight + signs.y * delta.y);
    shift = {
      x: signs.x * (node.width() - node.owidth) / 2,
      y: signs.y * (node.height() - node.oheight) / 2
    };
    shift = rotate(shift, node._rotation);
    node[x] = node.ox + shift.x;
    node[y] = node.oy + shift.y;
    nodes.call(update_node);
  }
  return svg.tick();
}).on("dragend", function(handle) {
  var node;
  if (d3.event.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', false);
  svg.svg.classed('resizing', false);
  node = d3.select($(this).closest('.node').get(0)).data()[0];
  node.ox = node.oy = node.owidth = node.oheight = null;
  node.fixed = false;
  return svg.sync(true);
});

anchor_link_drag = d3.behavior.drag().on("dragstart", function(anchor) {
  var link, node, type;
  if (d3.event.sourceEvent.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', true);
  svg.svg.classed('linking', true);
  node = d3.select($(this).closest('.node').get(0)).data()[0];
  type = diagram.last_types.link || diagram.types.links[0];
  link = new type(node, diagram.mouse);
  link.source_anchor = anchor;
  diagram.linking.push(link);
  svg.sync(true);
  return d3.event.sourceEvent.stopPropagation();
}).on("drag", function(anchor) {
  var node;
  if (d3.event.ctrlKey) {
    return;
  }
  node = d3.select($(this).closest('.node').get(0)).data()[0];
  return svg.tick();
}).on("dragend", function(anchor) {
  var node;
  if (d3.event.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', false);
  svg.svg.classed('linking', false);
  node = d3.select($(this).closest('.node').get(0)).data()[0];
  diagram.linking = [];
  return svg.sync(true);
});

mouse_anchor = function(anchor) {
  var _this = this;
  return anchor.on("mousemove", function(anchor) {
    var lnk, node, _i, _len, _ref55, _results;
    if (d3.event.ctrlKey) {
      return;
    }
    d3.select(this).classed('active', true);
    node = d3.select($(this).closest('.node').get(0)).data()[0];
    _ref55 = diagram.linking;
    _results = [];
    for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
      lnk = _ref55[_i];
      if (lnk._drag && lnk._drag === 'source') {
        lnk.source_anchor = anchor;
        _results.push(lnk.source = node);
      } else {
        lnk.target_anchor = anchor;
        _results.push(lnk.target = node);
      }
    }
    return _results;
  }).on("mouseout", function(anchor) {
    var lnk, _i, _len, _ref55, _results;
    if (d3.event.ctrlKey) {
      return;
    }
    d3.select(this).classed('active', false);
    _ref55 = diagram.linking;
    _results = [];
    for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
      lnk = _ref55[_i];
      if (lnk._drag && lnk._drag === 'source') {
        lnk.source_anchor = null;
        _results.push(lnk.source = diagram.mouse);
      } else {
        lnk.target_anchor = null;
        _results.push(lnk.target = diagram.mouse);
      }
    }
    return _results;
  }).on("mouseup", function(anchor) {
    var lnk, node, _i, _len, _ref55, _ref56;
    if (d3.event.ctrlKey) {
      return;
    }
    node = d3.select($(_this).closest('.node').get(0)).data()[0];
    if (diagram.linking.length) {
      _ref55 = diagram.linking;
      for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
        lnk = _ref55[_i];
        if ((_ref56 = diagram.mouse) !== lnk.source && _ref56 !== lnk.target) {
          diagram.links.push(lnk);
        }
      }
      diagram.linking = [];
      svg.sync(true);
      return d3.event.preventDefault();
    }
  });
};

mouse_node = function(node) {
  var _this = this;
  return node.on("mousedown", function(node) {
    var selected;
    if (d3.event.ctrlKey) {
      return;
    }
    selected = __indexOf.call(diagram.selection, node) >= 0;
    if ((selected && !diagram.dragging) || (!selected) && !d3.event.shiftKey) {
      diagram.selection = [node];
    }
    if (d3.event.shiftKey && !selected) {
      diagram.selection.push(node);
    }
    node.ts = timestamp();
    svg.svg.selectAll('g.node').sort(order);
    svg.svg.selectAll('g.element').each(function(elt) {
      if (__indexOf.call(diagram.selection, elt) < 0 && node.contains(elt)) {
        return diagram.selection.push(elt);
      }
    });
    return svg.tick();
  }).on("mousemove", function(node) {
    var lnk, _i, _len, _ref55, _results;
    if (d3.event.ctrlKey) {
      return;
    }
    _ref55 = diagram.linking;
    _results = [];
    for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
      lnk = _ref55[_i];
      if (lnk._drag && lnk._drag === 'source') {
        _results.push(lnk.source = node);
      } else {
        _results.push(lnk.target = node);
      }
    }
    return _results;
  }).on("mouseout", function(node) {
    var lnk, _i, _len, _ref55, _results;
    if (d3.event.ctrlKey) {
      return;
    }
    _ref55 = diagram.linking;
    _results = [];
    for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
      lnk = _ref55[_i];
      if (lnk._drag && lnk._drag === 'source') {
        _results.push(lnk.source = diagram.mouse);
      } else {
        _results.push(lnk.target = diagram.mouse);
      }
    }
    return _results;
  }).on("mouseup", function(node) {
    var lnk, _i, _len, _ref55, _ref56;
    if (d3.event.ctrlKey) {
      return;
    }
    if (diagram.linking.length) {
      _ref55 = diagram.linking;
      for (_i = 0, _len = _ref55.length; _i < _len; _i++) {
        lnk = _ref55[_i];
        if ((_ref56 = diagram.mouse) !== lnk.source && _ref56 !== lnk.target) {
          diagram.links.push(lnk);
        }
      }
      diagram.linking = [];
      svg.sync(true);
      return d3.event.preventDefault();
    }
  }).on('dblclick', function(node) {
    if (d3.event.ctrlKey) {
      return;
    }
    return edit((function() {
      return node.text;
    }), (function(txt) {
      return node.text = txt;
    }));
  });
};

mouse_link = function(link) {
  return link.on('mousedown', function(lnk) {
    if (!d3.event.shiftKey) {
      diagram.selection = [];
    }
    diagram.selection.push(lnk);
    svg.tick();
    return d3.event.stopPropagation();
  }).on('dblclick', function(lnk) {
    var nearest;
    if (d3.event.ctrlKey) {
      return;
    }
    nearest = lnk.nearest(diagram.mouse);
    if (nearest === lnk.source) {
      return edit((function() {
        return lnk.text.source;
      }), (function(txt) {
        return lnk.text.source = txt;
      }));
    } else {
      return edit((function() {
        return lnk.text.target;
      }), (function(txt) {
        return lnk.text.target = txt;
      }));
    }
  });
};

link_drag = d3.behavior.drag().on("dragstart", function(link) {
  var nearest;
  if (d3.event.sourceEvent.ctrlKey) {
    return;
  }
  if (!d3.event.sourceEvent.shiftKey && Math.min(dist(diagram.mouse, link.a1), dist(diagram.mouse, link.a2)) > 20) {
    return;
  }
  svg.svg.classed('dragging', true);
  svg.svg.classed('linking', true);
  diagram.links.splice(diagram.links.indexOf(link), 1);
  nearest = link.nearest(diagram.mouse);
  if (link.source === nearest) {
    link.source = diagram.mouse;
    link.source_anchor = null;
    link._drag = 'source';
  } else {
    link.target = diagram.mouse;
    link.target_anchor = null;
    link._drag = 'target';
  }
  diagram.linking.push(link);
  svg.sync();
  return d3.event.sourceEvent.stopPropagation();
}).on("drag", function(anchor) {
  if (d3.event.ctrlKey) {
    return;
  }
  return svg.tick();
}).on("dragend", function(anchor) {
  if (d3.event.ctrlKey) {
    return;
  }
  svg.svg.classed('dragging', false);
  svg.svg.classed('linking', false);
  diagram.linking = [];
  return svg.sync(true);
});

enter_node = function(nodes, connect) {
  var g;
  if (connect == null) {
    connect = true;
  }
  g = nodes.append('g').attr('class', function(node) {
    return 'node ' + (node instanceof Group ? 'group' : 'element');
  });
  g.append('path').attr('class', 'ghost');
  g.append('path').attr('class', function(node) {
    return "shape fill-" + node.cls.fill + " stroke-" + node.cls.stroke;
  });
  g.append('text');
  if (!connect) {
    return;
  }
  g.append('g').attr('class', 'handles').each(function(node) {
    return d3.select(this).selectAll('.handle').data(node.handle_list()).enter().append('path').attr('class', function(handle) {
      return "handle " + handle;
    }).call(nsweo_resize_drag);
  });
  g.append('g').attr('class', 'anchors').each(function(node) {
    return d3.select(this).selectAll('.anchor').data(node.anchor_list()).enter().append('path').attr('class', function(anchor) {
      return "anchor " + anchor;
    }).call(mouse_anchor).call(anchor_link_drag);
  });
  g.call(move_drag);
  return g.call(mouse_node);
};

write_text = function(txt, text) {
  var i, line, tspan, _i, _len, _ref55, _results;
  txt.selectAll('tspan').remove();
  _ref55 = text.split('\n');
  _results = [];
  for (i = _i = 0, _len = _ref55.length; _i < _len; i = ++_i) {
    line = _ref55[i];
    tspan = txt.append('tspan').text(line).attr('x', 0);
    if (i !== 0) {
      _results.push(tspan.attr('dy', '1.2em'));
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

update_node = function(nodes) {
  nodes.select('text').each(function(node) {
    var current_text, txt;
    txt = d3.select(this);
    current_text = txt.selectAll('tspan')[0].map(function(e) {
      return d3.select(e).text();
    }).join('\n');
    if (node.text === current_text) {
      return;
    }
    return txt.call(write_text, node.text);
  }).each(function(node) {
    return node.set_txt_bbox(this.getBBox());
  }).attr('x', function(node) {
    return node.txt_x();
  }).attr('y', function(node) {
    return node.txt_y();
  }).selectAll('tspan').attr('x', function(node) {
    return node.txt_x();
  });
  nodes.select('.shape').attr('class', function(node) {
    return "shape fill-" + node.cls.fill + " stroke-" + node.cls.stroke;
  }).attr('d', function(node) {
    return node.path();
  });
  nodes.select('.ghost').attr('d', function(node) {
    return Rect.prototype.path.apply(node);
  });
  nodes.call(update_handles);
  return nodes.call(update_anchors);
};

enter_link = function(links, connect) {
  var g;
  if (connect == null) {
    connect = true;
  }
  g = links.append('g').attr("class", "link");
  g.append("path").attr('class', 'ghost');
  g.append("path").attr('class', function(link) {
    return "shape " + link.cls.type;
  }).attr("marker-end", function(link) {
    return "url(#" + link.cls.marker.id + ")";
  });
  g.each(function(link) {
    var node, txt;
    node = d3.select(this);
    if (link.text.source) {
      txt = node.append("text").attr('class', "start").call(write_text, link.text.source);
      link._source_bbox = txt.node().getBBox();
    }
    if (link.text.target) {
      txt = node.append("text").attr('class', "end").call(write_text, link.text.target);
      return link._target_bbox = txt.node().getBBox();
    }
  });
  if (connect) {
    g.call(mouse_link);
    return g.call(link_drag);
  }
};

update_link = function(links) {
  links.each(function(link) {
    var g, txt;
    g = d3.select(this);
    txt = g.select('text.start').node();
    if (link.text.source && !txt) {
      g.append('text').attr('class', 'start');
    }
    txt = g.select('text.end').node();
    if (link.text.target && !txt) {
      return g.append('text').attr('class', 'end');
    }
  });
  links.select('text.start').each(function(link) {
    var text, txt;
    txt = d3.select(this);
    text = txt.text();
    if (link.text.source === text && (link._source_bbox != null)) {
      return;
    }
    if (link.text.source.trim() === '') {
      txt.remove();
      return;
    }
    txt.call(write_text, link.text.source);
    return link._source_bbox = txt.node().getBBox();
  });
  return links.select('text.end').each(function(link) {
    var text, txt;
    txt = d3.select(this);
    text = txt.text();
    if (!link.text.target === text && (link._target_bbox != null)) {
      return;
    }
    if (link.text.target.trim() === '') {
      txt.remove();
      return;
    }
    txt.call(write_text, link.text.target);
    return link._target_bbox = txt.node().getBBox();
  });
};

update_handles = function(nodes) {
  return nodes.each(function(node) {
    var s;
    s = node.cls.handle_size;
    return d3.select(this).selectAll('.handle').data(node.handle_list()).attr('d', function(handle) {
      var h, signs;
      h = node.handles[handle]();
      if (handle !== 'O') {
        signs = cardinal_to_direction(handle);
        return "M " + h.x + " " + h.y + "                     L " + (h.x + signs.x * s) + " " + h.y + "                     L " + (h.x + signs.x * s) + " " + (h.y + signs.y * s) + "                     L " + h.x + " " + (h.y + signs.y * s) + "                    z";
      } else {
        return "M " + h.x + " " + h.y + "                     L " + h.x + " " + (h.y - 2 * s) + "                     A " + s + " " + s + " 0 1 1 " + h.x + " " + (h.y - 4 * s) + "                     A " + s + " " + s + " 0 1 1 " + h.x + " " + (h.y - 2 * s) + "                    ";
      }
    });
  });
};

update_anchors = function(nodes) {
  return nodes.each(function(node) {
    var s;
    s = node.cls.handle_size;
    return d3.select(this).selectAll('.anchor').data(node.anchor_list()).attr('transform', function(anchor) {
      var a;
      a = node.anchors[anchor]();
      return "rotate(" + (to_svg_angle(anchor)) + ", " + (a.x - node.x) + ", " + (a.y - node.y) + ")";
    }).attr('d', function(anchor) {
      var a;
      a = node.anchors[anchor]();
      if (void 0 === a.x || void 0 === a.y) {
        return 'M 0 0';
      }
      a.x -= node.x;
      a.y -= node.y;
      return "M " + a.x + " " + a.y + "                 L " + a.x + " " + (a.y + s) + "                 L " + (a.x + s) + " " + a.y + "                 L " + a.x + " " + (a.y - s) + "                 z";
    });
  });
};

tick_node = function(nodes) {
  return nodes.attr("transform", (function(node) {
    return "translate(" + node.x + "," + node.y + ")rotate(" + (to_svg_angle(node._rotation)) + ")";
  })).classed('selected', function(node) {
    return __indexOf.call(diagram.selection, node) >= 0;
  });
};

tick_link = function(links) {
  links.classed('selected', function(link) {
    return __indexOf.call(diagram.selection, link) >= 0;
  });
  links.each(function(link) {
    return d3.select(this).selectAll('path').attr('d', link.path());
  });
  links.select('text.start').attr('transform', function(link) {
    var bb, delta, pos;
    bb = link._source_bbox;
    pos = {
      x: link.text_margin + bb.width / 2,
      y: -link.text_margin - bb.height / 2
    };
    delta = rotate(pos, link.o1);
    return "translate(" + (link.a1.x + delta.x) + ", " + (link.a1.y + delta.y) + ")";
  });
  return links.select('text.end').attr('transform', function(link) {
    var bb, delta, pos;
    bb = link._target_bbox;
    pos = {
      x: link.text_margin + bb.width / 2,
      y: -link.text_margin - bb.height / 2
    };
    delta = rotate(pos, link.o2);
    return "translate(" + (link.a2.x + delta.x) + ", " + (link.a2.y + delta.y) + ")";
  });
};

mouse_xy = function(e) {
  var m;
  m = d3.mouse(e);
  return {
    x: (m[0] - diagram.zoom.translate[0]) / diagram.zoom.scale,
    y: (m[1] - diagram.zoom.translate[1]) / diagram.zoom.scale
  };
};

zoom = d3.behavior.zoom();

Svg = (function(_super) {
  __extends(Svg, _super);

  function Svg() {
    this.create = __bind(this.create, this);
    var article, markers,
      _this = this;
    Svg.__super__.constructor.apply(this, arguments);
    article = d3.select("article").node();
    this.width = article.clientWidth;
    this.height = article.clientHeight || 500;
    this.zoom = zoom.scale(diagram.zoom.scale).translate(diagram.zoom.translate).scaleExtent([.05, 5]).on("zoom", function() {
      var _ref55;
      if (((_ref55 = d3.event.sourceEvent.type) === 'wheel' || _ref55 === 'click') || d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.which === 2) {
        diagram.zoom.translate = d3.event.translate;
        diagram.zoom.scale = d3.event.scale;
        return svg.sync_transform();
      }
    }).on("zoomend", function() {
      return svg.sync(true);
    });
    d3.select("article").selectAll('svg').data([diagram]).enter().append("svg").attr('id', "diagram").attr("width", this.width).attr("height", this.height).call(this.create);
    this.svg = d3.select('#diagram');
    markers = this.svg.select('defs').selectAll('marker').data(diagram.markers());
    markers.enter().append('marker').attr('id', function(m) {
      return m.id;
    }).attr('viewBox', '-10 -10 30 30').attr('refX', 20).attr('refY', 5).attr('markerUnits', 'userSpaceOnUse').attr('markerWidth', 40).attr('markerHeight', 40).attr('orient', 'auto').append('path').attr('d', function(m) {
      return m.path();
    });
    markers.exit().remove();
    this.svg.on("mousedown", function(event) {
      var mouse;
      if (!d3.select(d3.event.target).classed('background') || d3.event.ctrlKey || d3.event.which === 2) {
        return;
      }
      if (d3.event.altKey && d3.event.shiftKey) {
        diagram.groupping = true;
      }
      if (!d3.event.shiftKey) {
        diagram.selection = [];
        svg.tick();
      }
      mouse = mouse_xy(_this.svg.node());
      _this.svg.select(diagram.groupping ? 'g.underlay' : 'g.overlay').append("rect").attr({
        "class": "selection",
        x: mouse.x,
        y: mouse.y,
        width: 0,
        height: 0
      });
      return d3.event.preventDefault();
    });
    d3.select(window).on("mousemove", function() {
      var mouse, move, rect, sel;
      if (d3.event.ctrlKey) {
        return;
      }
      mouse = mouse_xy(_this.svg.node());
      diagram.mouse.lasts.push({
        x: diagram.mouse.x - mouse.x,
        y: diagram.mouse.y - mouse.y
      });
      diagram.mouse.dynamic_rotation();
      diagram.mouse.lasts.shift();
      diagram.mouse.x = mouse.x;
      diagram.mouse.y = mouse.y;
      sel = _this.svg.select("rect.selection");
      if (!sel.empty()) {
        rect = {
          x: +sel.attr("x"),
          y: +sel.attr("y"),
          width: +sel.attr("width"),
          height: +sel.attr("height")
        };
        move = {
          x: mouse.x - rect.x,
          y: mouse.y - rect.y
        };
        if (move.x < 1 || (move.x * 2 < rect.width)) {
          rect.x = mouse.x;
          rect.width -= move.x;
        } else {
          rect.width = move.x;
        }
        if (move.y < 1 || (move.y * 2 < rect.height)) {
          rect.y = mouse.y;
          rect.height -= move.y;
        } else {
          rect.height = move.y;
        }
        rect.width = Math.max(0, rect.width);
        rect.height = Math.max(0, rect.height);
        sel.attr(rect);
        _this.svg.selectAll('g.node').each(function(elt) {
          var g, selected;
          g = d3.select(this);
          selected = __indexOf.call(diagram.selection, elt) >= 0;
          if (elt["in"](rect) && !selected) {
            return diagram.selection.push(elt);
          } else if (!elt["in"](rect) && selected && !d3.event.shiftKey) {
            return diagram.selection.splice(diagram.selection.indexOf(elt), 1);
          }
        });
        svg.tick();
        return d3.event.preventDefault();
      }
    }).on("mouseup", function() {
      var grp, height, nth, sel, type, width, x, y;
      if (d3.event.ctrlKey) {
        return;
      }
      if (diagram.linking.length) {
        diagram.linking = [];
        _this.sync();
      }
      if (diagram.groupping) {
        sel = _this.svg.select("rect.selection");
        x = +sel.attr("x");
        y = +sel.attr("y");
        width = +sel.attr("width");
        height = +sel.attr("height");
        type = diagram.last_types.group || diagram.types.groups[0];
        if (type) {
          nth = diagram.groups.filter(function(grp) {
            return grp instanceof type;
          }).length + 1;
          grp = new type(x + width / 2, y + height / 2, "" + type.name + " #" + nth, !diagram.force);
          grp._width = width;
          grp._height = height;
          diagram.groups.push(grp);
        }
        diagram.groupping = false;
        _this.sync();
      }
      _this.svg.selectAll("rect.selection").remove();
      return d3.event.preventDefault();
    }).on("keydown", function() {
      if (d3.event.ctrlKey) {
        return d3.select('.background').classed('move', true);
      }
    }).on("keyup", function() {
      return d3.select('.background').classed('move', false);
    });
  }

  Svg.prototype.sync_transform = function() {
    d3.select('.root').attr("transform", "translate(" + diagram.zoom.translate + ")scale(" + diagram.zoom.scale + ")");
    return d3.select('#grid').attr("patternTransform", "translate(" + diagram.zoom.translate + ")scale(" + diagram.zoom.scale + ")");
  };

  Svg.prototype.create = function(svg) {
    var background, background_g, defs, pattern, root,
      _this = this;
    defs = svg.append('defs');
    background_g = svg.append('g').attr('id', 'bg');
    background = background_g.append('rect').attr('class', 'background').attr('width', this.width).attr('height', this.height).attr('fill', 'url(#grid)').call(this.zoom);
    svg.append('text').attr('id', 'title').attr('x', this.width / 2).attr('y', 50).on('dblclick', function() {
      return edit((function() {
        return diagram.title;
      }), (function(txt) {
        return diagram.title = txt;
      }));
    });
    d3.select(window).on('resize', function() {
      return _this.resize();
    });
    pattern = defs.append('pattern').attr('id', 'grid').attr('viewBox', '0 0 10 10').attr('x', 0).attr('y', 0).attr('width', diagram.snap.x).attr('height', diagram.snap.y).attr('patternUnits', 'userSpaceOnUse');
    pattern.append('path').attr('d', 'M 10 0 L 0 0 L 0 10');
    root = background_g.append('g').attr('class', 'root');
    root.append('g').attr('class', 'underlay');
    root.append('g').attr('class', 'groups');
    root.append('g').attr('class', 'links');
    root.append('g').attr('class', 'elements');
    return root.append('g').attr('class', 'overlay');
  };

  Svg.prototype.sync = function(persist) {
    var element, group, link;
    if (persist == null) {
      persist = false;
    }
    this.zoom.scale(diagram.zoom.scale);
    this.zoom.translate(diagram.zoom.translate);
    this.sync_transform();
    this.svg.select('#title').text(diagram.title);
    group = this.svg.select('g.groups').selectAll('g.group').data(diagram.groups.sort(order));
    element = this.svg.select('g.elements').selectAll('g.element').data(diagram.elements.sort(order));
    link = this.svg.select('g.links').selectAll('g.link').data(diagram.links.concat(diagram.linking));
    group.enter().call(enter_node);
    element.enter().call(enter_node);
    link.enter().call(enter_link);
    group.call(update_node);
    element.call(update_node);
    link.call(update_link);
    group.exit().remove();
    element.exit().remove();
    link.exit().remove();
    this.tick();
    if (persist && !diagram.force) {
      generate_url();
    }
    if (diagram.force) {
      diagram.force.stop();
      diagram.force.nodes(diagram.nodes()).links(diagram.links);
      return diagram.force.start();
    }
  };

  Svg.prototype.tick = function() {
    this.svg.select('g.groups').selectAll('g.group').call(tick_node);
    this.svg.select('g.elements').selectAll('g.element').call(tick_node);
    return this.svg.select('g.links').selectAll('g.link').call(tick_link);
  };

  Svg.prototype.resize = function() {
    var article;
    article = d3.select("article").node();
    this.width = article.clientWidth;
    this.height = article.clientHeight || 500;
    this.svg.attr("width", this.width).attr("height", this.height);
    d3.select('.background').attr("width", this.width).attr("height", this.height);
    return this.svg.select('#title').attr('x', this.width / 2);
  };

  return Svg;

})(Base);

load = function(data) {
  var Type;
  Type = Diagram.diagrams[data.name];
  window.diagram = new Type();
  window.svg = new Svg();
  return diagram.loads(data);
};

save = function() {
  return localStorage.setItem("" + diagram.cls.name + "|" + diagram.title, diagram.hash());
};

generate_url = function() {
  var hash;
  hash = '#' + diagram.hash();
  if (location.hash !== hash) {
    return history.pushState(null, null, hash);
  }
};

history_pop = function() {
  var $diagrams, $editor, e1, e2, e21, e22, e3, e4, ex1, ex2;
  $diagrams = $('#diagrams');
  $editor = $('#editor');
  if (!location.hash) {
    $diagrams.removeClass('hidden');
    $editor.addClass('hidden');
    list_diagrams();
    return;
  }
  $editor.removeClass('hidden');
  $diagrams.addClass('hidden');
  try {
    load(JSON.parse(LZString.decompressFromBase64(location.hash.slice(1))));
  } catch (_error) {
    ex1 = _error;
    try {
      load(JSON.parse(decodeURIComponent(escape(atob(location.hash.slice(1))))));
    } catch (_error) {
      ex2 = _error;
      window.diagram = new DotDiagram();
      window.svg = new Svg();
      diagram.title = 'There was an error loading your diagram :(';
      diagram.elements.push(e1 = new Note(void 0, void 0, ex1.message));
      diagram.elements.push(e2 = new Note(void 0, void 0, ex1.stack));
      diagram.elements.push(e21 = new Note(void 0, void 0, ex2.message));
      diagram.elements.push(e22 = new Note(void 0, void 0, ex2.stack));
      diagram.elements.push(e3 = new Note(void 0, void 0, 'You can try to reload\nyour browser without cache'));
      diagram.elements.push(e4 = new Note(void 0, void 0, 'Otherwise it may be that\n your diagram is not compatible\nwith this version'));
      diagram.links.push(new NormalLink(e2, e1));
      diagram.links.push(new NormalLink(e2, e3));
      diagram.links.push(new NormalLink(e2, e4));
      diagram.links.push(new NormalLink(e21, e1));
      diagram.links.push(new NormalLink(e22, e2));
      diagram.links.push(new NormalLink(e21, e22));
      diagram.start_force();
    }
  }
  if (diagram.cls.name !== $('aside h3').attr('id')) {
    init_commands();
    svg.resize();
  }
  return svg.sync();
};

list_diagrams = function() {
  var $tbody, $tr, b64_diagram, diagram, key, name, title, type, _ref55, _ref56, _results;
  $tbody = $('#diagrams tbody');
  $tbody.find('.local').remove();
  for (key in localStorage) {
    b64_diagram = localStorage[key];
    _ref55 = key.split('|'), type = _ref55[0], title = _ref55[1];
    if (title == null) {
      continue;
    }
    $tbody.append($tr = $('<tr>'));
    $tr.addClass('local').append($('<td>').text(title), $('<td>').text((new Diagram.diagrams[type]()).label), $('<td>').append($('<a>').attr('href', "#" + b64_diagram).append($('<i>', {
      "class": 'glyphicon glyphicon-folder-open'
    }))).append($('<a>').attr('href', "#").append($('<i>', {
      "class": 'glyphicon glyphicon-trash'
    })).on('click', (function(k) {
      return function() {
        localStorage.removeItem(k);
        $(this).closest('tr').remove();
        return false;
      };
    })(key))));
  }
  $('#diagrams tr.new').remove();
  _ref56 = Diagram.diagrams;
  _results = [];
  for (name in _ref56) {
    type = _ref56[name];
    diagram = new type();
    b64_diagram = diagram.hash();
    $tbody.append($tr = $('<tr>'));
    _results.push($tr.addClass('new').append($('<td>').text('Create a new'), $('<td>').text(diagram.label), $('<td>').append($('<a>').attr('href', "#" + b64_diagram).append($('<i>', {
      "class": 'glyphicon glyphicon-file'
    })))));
  }
  return _results;
};

KEYWORDS = ['node', 'edge', 'graph', 'digraph', 'subgraph', 'strict'];

BRACES = ['[', '{', '}', ']'];

DELIMITERS = [':', ';', ','];

OPERATORS = ['--', '->'];

COMPASS_PTS = ['n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw', 'c', '_'];

RE_SPACE = /\s/;

RE_ALPHA = /\w/;

RE_DIGIT = /[\d|.]/;

RE_ALPHADIGIT = /[\d|\w]/;

PANIC_THRESHOLD = 9999;

Token = (function() {
  function Token(value) {
    this.value = value;
  }

  return Token;

})();

Keyword = (function(_super) {
  __extends(Keyword, _super);

  function Keyword() {
    _ref55 = Keyword.__super__.constructor.apply(this, arguments);
    return _ref55;
  }

  return Keyword;

})(Token);

Id = (function(_super) {
  __extends(Id, _super);

  function Id() {
    _ref56 = Id.__super__.constructor.apply(this, arguments);
    return _ref56;
  }

  return Id;

})(Token);

Number = (function(_super) {
  __extends(Number, _super);

  function Number() {
    _ref57 = Number.__super__.constructor.apply(this, arguments);
    return _ref57;
  }

  return Number;

})(Id);

QuotedId = (function(_super) {
  __extends(QuotedId, _super);

  function QuotedId() {
    _ref58 = QuotedId.__super__.constructor.apply(this, arguments);
    return _ref58;
  }

  return QuotedId;

})(Id);

Brace = (function(_super) {
  __extends(Brace, _super);

  function Brace() {
    _ref59 = Brace.__super__.constructor.apply(this, arguments);
    return _ref59;
  }

  return Brace;

})(Token);

Delimiter = (function(_super) {
  __extends(Delimiter, _super);

  function Delimiter() {
    _ref60 = Delimiter.__super__.constructor.apply(this, arguments);
    return _ref60;
  }

  return Delimiter;

})(Token);

Assign = (function(_super) {
  __extends(Assign, _super);

  function Assign() {
    _ref61 = Assign.__super__.constructor.apply(this, arguments);
    return _ref61;
  }

  return Assign;

})(Token);

Operator = (function(_super) {
  __extends(Operator, _super);

  function Operator() {
    _ref62 = Operator.__super__.constructor.apply(this, arguments);
    return _ref62;
  }

  return Operator;

})(Token);

dot_tokenize = function(s) {
  var chr, col, escape, id, last_chr, len, op, pos, row, token, tokens, _ref63, _ref64;
  pos = 0;
  row = 0;
  col = 0;
  len = s.length;
  tokens = [];
  last_chr = chr = null;
  while (pos < len) {
    last_chr = chr;
    token = null;
    col++;
    chr = s[pos++];
    if (chr.match(/\s/)) {
      if (chr === '\n') {
        row++;
        col = 0;
      }
      continue;
    } else if (chr === '=') {
      token = new Assign(chr);
    } else if (chr === '-') {
      op = chr + s[pos++];
      if (__indexOf.call(OPERATORS, op) >= 0) {
        token = new Operator(op);
      }
    } else if (__indexOf.call(BRACES, chr) >= 0) {
      token = new Brace(chr);
    } else if (__indexOf.call(DELIMITERS, chr) >= 0) {
      token = new Delimiter(chr);
    } else if (chr.match(/[A-Za-z_]/)) {
      id = chr;
      while ((_ref63 = (chr = s[pos++])) != null ? _ref63.match(/\w/) : void 0) {
        id += chr;
      }
      pos--;
      if (__indexOf.call(KEYWORDS, id) >= 0) {
        token = new Keyword(id);
      } else {
        token = new Id(id);
      }
    } else if (chr === '"') {
      id = '';
      escape = false;
      while (((chr = s[pos++]) !== '"' || escape) && (chr != null)) {
        if (chr === '\\' && !escape) {
          escape = true;
          continue;
        }
        if (escape) {
          if (chr === 'n') {
            chr = '\n';
          } else if (chr === 't') {
            chr = '\t';
          } else if (chr === 'r') {
            chr = '\r';
          } else if (chr === '"') {
            chr = '"';
          } else if (chr === '\\') {
            chr = '\\';
          } else if (chr === '\n') {
            chr = '';
          }
        }
        id += chr;
        escape = false;
      }
      token = new QuotedId(id);
    } else if (chr.match(/\d|\./)) {
      id = chr;
      while ((_ref64 = (chr = s[pos++])) != null ? _ref64.match(/\d|\./) : void 0) {
        id += chr;
      }
      pos--;
      token = new Number(parseFloat(id));
    } else if (chr.match(/\/|\#/)) {
      if (chr === '/' && s[pos] === '*') {
        pos += 2;
        while (!((chr = s[pos]) === '*' && s[pos + 1] === '/') && (chr != null)) {
          if (chr === '\n') {
            row++;
            col = 0;
          } else {
            col++;
          }
          pos++;
        }
        pos += 2;
      } else {
        if (chr === '#' || (chr === '/' && s[pos] === '/')) {
          while (!((chr = s[pos]) === '\n') && (chr != null)) {
            col++;
            pos++;
          }
        }
      }
    } else {
      throw "[Dot Tokenizer] Syntax error in dot " + chr + " at " + row + ", " + col;
    }
    if (token) {
      tokens.push(token);
    }
  }
  return tokens;
};

Graph = (function() {
  function Graph(type, id, strict) {
    this.type = type;
    this.id = id;
    this.strict = strict;
    this.statements = [];
  }

  return Graph;

})();

Statement = (function() {
  function Statement() {}

  Statement.prototype.get_attrs = function() {
    var attribute, attrs, _i, _len, _ref63;
    attrs = {};
    _ref63 = this.attributes;
    for (_i = 0, _len = _ref63.length; _i < _len; _i++) {
      attribute = _ref63[_i];
      attrs[attribute.left] = attribute.right;
    }
    return attrs;
  };

  return Statement;

})();

SubGraph = (function() {
  function SubGraph(id) {
    this.id = id;
    this.statements = [];
  }

  return SubGraph;

})();

Node = (function(_super) {
  __extends(Node, _super);

  function Node(id, port, compass_pt) {
    this.id = id;
    this.port = port;
    this.compass_pt = compass_pt;
  }

  return Node;

})(Statement);

Edge = (function(_super) {
  __extends(Edge, _super);

  function Edge() {
    this.nodes = [];
    this.attributes = [];
  }

  return Edge;

})(Statement);

Attribute = (function() {
  function Attribute(left, right) {
    this.left = left;
    this.right = right;
  }

  return Attribute;

})();

Attributes = (function(_super) {
  __extends(Attributes, _super);

  function Attributes(type) {
    this.type = type;
    this.attributes = [];
  }

  return Attributes;

})(Statement);

dot_lex = function(tokens) {
  var graph, id, level, parse_attribute, parse_attribute_list, parse_node, parse_node_list, parse_statement, parse_statement_list, parse_subgraph, pos, strict, type;
  pos = 0;
  level = 0;
  if (!(tokens[pos] instanceof Keyword)) {
    throw 'First token is not a keyword';
  }
  strict = false;
  if (tokens[pos].value === 'strict') {
    strict = true;
    pos++;
  }
  type = null;
  if (tokens[pos].value === 'graph') {
    type = 'normal';
  } else if (tokens[pos].value === 'digraph') {
    type = 'directed';
  }
  if (type === null) {
    throw 'Unknown graph type';
  }
  id = null;
  if (tokens[++pos] instanceof Id) {
    id = tokens[pos++].value;
  }
  parse_attribute = function() {
    var left, right;
    if (tokens[pos] instanceof Brace && tokens[pos].value === ']') {
      if (tokens[pos + 1] instanceof Brace && tokens[pos + 1].value === '[') {
        pos += 2;
      } else {
        return null;
      }
    }
    if (!(tokens[pos] instanceof Id)) {
      throw "Invalid left hand side of attribute '" + tokens[pos].value + "'";
    }
    left = tokens[pos].value;
    pos++;
    if (!(tokens[pos] instanceof Assign)) {
      throw "Invalid assignement '" + tokens[pos].value + "'";
    }
    pos++;
    if (!(tokens[pos] instanceof Id)) {
      throw "Invalid right hand side of attribute '" + tokens[pos].value + "'";
    }
    right = tokens[pos].value;
    return new Attribute(left, right);
  };
  parse_attribute_list = function() {
    var attribute, attributes, panic;
    if (!(tokens[pos] instanceof Brace && tokens[pos].value === '[')) {
      throw 'No opening brace "[" for attribute list';
    }
    pos++;
    attributes = [];
    panic = 0;
    while (panic++ < PANIC_THRESHOLD) {
      attribute = parse_attribute();
      if (attribute === null) {
        break;
      } else {
        pos++;
        attributes.push(attribute);
        if (tokens[pos] instanceof Delimiter && tokens[pos].value === ',') {
          pos++;
        }
      }
    }
    if (--panic === PANIC_THRESHOLD) {
      throw 'Infinite loop for statement list parsing';
    }
    return attributes;
  };
  parse_subgraph = function() {
    var subgraph;
    id = null;
    if (tokens[pos] instanceof Keyword && tokens[pos].value === 'subgraph') {
      pos++;
      if (tokens[pos] instanceof Id) {
        id = tokens[pos++].value;
      }
    }
    subgraph = new SubGraph(id);
    subgraph.statements = parse_statement_list();
    return subgraph;
  };
  parse_node = function() {
    var compass_pt, node, port, _ref63;
    if (tokens[pos] instanceof Keyword && tokens[pos].value === 'subgraph') {
      node = parse_subgraph();
    } else if (tokens[pos] instanceof Brace && tokens[pos].value === '{') {
      node = parse_subgraph();
    } else {
      if (!(tokens[pos] instanceof Id)) {
        throw "Invalid edge id '" + tokens[pos].value + "'";
      }
      id = tokens[pos].value;
      port = null;
      compass_pt = null;
      if (tokens[pos + 1] instanceof Delimiter && tokens[pos + 1].value === ':') {
        pos += 2;
        if (!(tokens[pos] instanceof Id)) {
          throw "Invalid port id '" + tokens[pos].value + "'";
        }
        port = tokens[pos].value;
        if (tokens[pos + 1] instanceof Delimiter && tokens[pos + 1].value === ':') {
          pos += 2;
          if (!(tokens[pos] instanceof Id) || (_ref63 = tokens[pos].value, __indexOf.call(COMPASS_PTS, _ref63) < 0)) {
            throw "Invalid compass point '" + tokens[pos].value + "'";
          }
          compass_pt = tokens[pos].value;
        }
        if (port && !compass_pt && __indexOf.call(COMPASS_PTS, port) >= 0) {
          compass_pt = port;
          port = null;
        }
      }
      node = new Node(id, port, compass_pt);
    }
    return node;
  };
  parse_node_list = function() {
    var node_list;
    node_list = [parse_node()];
    while (tokens[pos + 1] instanceof Operator) {
      pos += 2;
      node_list.push(parse_node());
    }
    return node_list;
  };
  parse_statement = function() {
    var left, statement, _ref63;
    if (tokens[pos] instanceof Brace && tokens[pos].value === '}') {
      return null;
    }
    if (tokens[pos] instanceof Keyword && tokens[pos].value !== 'subgraph') {
      if ((_ref63 = tokens[pos].value) !== 'graph' && _ref63 !== 'node' && _ref63 !== 'edge') {
        throw 'Unexpected keyword ' + tokens[pos];
      }
      statement = new Attributes(tokens[pos++].value);
      statement.attributes = parse_attribute_list();
      return statement;
    }
    if (!(tokens[pos] instanceof Id || (tokens[pos] instanceof Keyword && tokens[pos].value === 'subgraph') || (tokens[pos] instanceof Brace && tokens[pos].value === '{'))) {
      throw "Unexpected statement '" + tokens[pos].value + "'";
    }
    if (tokens[pos] instanceof Id && tokens[pos + 1] instanceof Assign) {
      left = tokens[pos].value;
      pos += 2;
      if (!(tokens[pos] instanceof Id)) {
        throw "Invalid right hand side of attribute '" + tokens[pos].value + "'";
      }
      statement = new Attribute(left, tokens[pos].value);
      return statement;
    }
    statement = new Edge();
    statement.nodes = parse_node_list();
    if (tokens[pos + 1] instanceof Brace && tokens[pos + 1].value === '[') {
      pos++;
      statement.attributes = parse_attribute_list();
    }
    return statement;
  };
  parse_statement_list = function() {
    var panic, statement, statements;
    if (!(tokens[pos] instanceof Brace && tokens[pos].value === '{')) {
      throw 'No opening brace "{" for statement list';
    }
    pos++;
    statements = [];
    panic = 0;
    while (panic++ < PANIC_THRESHOLD) {
      statement = parse_statement();
      if (statement === null) {
        break;
      } else {
        pos++;
        statements.push(statement);
        if (tokens[pos] instanceof Delimiter && tokens[pos].value === ';') {
          pos++;
        }
      }
    }
    if (--panic === PANIC_THRESHOLD) {
      throw 'Infinite loop for statement list parsing';
    }
    return statements;
  };
  graph = new Graph(type, id, strict);
  graph.statements = parse_statement_list();
  return window.g = graph;
};

dot = function(src) {
  var attributes, copy_attributes, d, elements_by_id, elt, graph, id, l, link_type, links_by_id, lnk, nodes_by_id, populate, tokens, _i, _len;
  tokens = dot_tokenize(src);
  graph = dot_lex(tokens);
  d = window.diagram = new DotDiagram();
  window.svg = new Svg();
  nodes_by_id = {};
  links_by_id = [];
  link_type = graph.type === 'directed' ? 'normal' : 'none';
  attributes = {
    graph: {},
    edge: {},
    node: {}
  };
  copy_attributes = function() {
    return {
      graph: copy(attributes.graph),
      edge: copy(attributes.edge),
      node: copy(attributes.node)
    };
  };
  populate = function(statements) {
    var Type, current_attributes, i, label, ltype, node, old_attributes, prev_node, statement, sub_node, sub_prev_node, sub_prev_statement, sub_statement, type, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = statements.length; _i < _len; _i++) {
      statement = statements[_i];
      if (statement instanceof Attributes) {
        merge(attributes[statement.type], statement.get_attrs());
        continue;
      }
      if (statement instanceof Attribute) {
        attributes.graph[statement.left] = statement.right;
        continue;
      }
      if (!(statement instanceof Edge)) {
        console.log("Unexpected " + statement);
        continue;
      }
      current_attributes = copy_attributes();
      if (statement.nodes.length === 1) {
        merge(current_attributes.node, statement.get_attrs());
      } else {
        merge(current_attributes.edge, statement.get_attrs());
      }
      _results.push((function() {
        var _j, _len1, _ref63, _results1;
        _ref63 = statement.nodes;
        _results1 = [];
        for (i = _j = 0, _len1 = _ref63.length; _j < _len1; i = ++_j) {
          node = _ref63[i];
          if (node instanceof SubGraph) {
            old_attributes = copy_attributes();
            populate(node.statements);
            attributes = old_attributes;
          } else {
            if (!(node.id in nodes_by_id) || statements.length === 1) {
              label = current_attributes.node.label || node.id;
              type = current_attributes.node.shape || 'ellipse';
              Type = window[capitalize(type)] || Ellipse;
              nodes_by_id[node.id] = {
                label: label,
                type: Type
              };
            }
          }
          if (i !== 0) {
            prev_node = statement.nodes[i - 1];
            ltype = window[capitalize(current_attributes.edge.arrowhead || link_type) + 'Link'] || NoneLink;
            if (prev_node instanceof SubGraph) {
              _results1.push((function() {
                var _k, _len2, _ref64, _results2;
                _ref64 = prev_node.statements;
                _results2 = [];
                for (_k = 0, _len2 = _ref64.length; _k < _len2; _k++) {
                  sub_prev_statement = _ref64[_k];
                  _results2.push((function() {
                    var _l, _len3, _ref65, _results3;
                    _ref65 = sub_prev_statement.nodes;
                    _results3 = [];
                    for (_l = 0, _len3 = _ref65.length; _l < _len3; _l++) {
                      sub_prev_node = _ref65[_l];
                      if (node instanceof SubGraph) {
                        _results3.push((function() {
                          var _len4, _m, _ref66, _results4;
                          _ref66 = node.statements;
                          _results4 = [];
                          for (_m = 0, _len4 = _ref66.length; _m < _len4; _m++) {
                            sub_statement = _ref66[_m];
                            _results4.push((function() {
                              var _len5, _n, _ref67, _results5;
                              _ref67 = sub_statement.nodes;
                              _results5 = [];
                              for (_n = 0, _len5 = _ref67.length; _n < _len5; _n++) {
                                sub_node = _ref67[_n];
                                _results5.push(links_by_id.push({
                                  type: ltype,
                                  id1: sub_prev_node.id,
                                  id2: sub_node.id,
                                  label: current_attributes.edge.label
                                }));
                              }
                              return _results5;
                            })());
                          }
                          return _results4;
                        })());
                      } else {
                        _results3.push(links_by_id.push({
                          type: ltype,
                          id1: sub_prev_node.id,
                          id2: node.id,
                          label: current_attributes.edge.label
                        }));
                      }
                    }
                    return _results3;
                  })());
                }
                return _results2;
              })());
            } else {
              if (node instanceof SubGraph) {
                _results1.push((function() {
                  var _k, _len2, _ref64, _results2;
                  _ref64 = node.statements;
                  _results2 = [];
                  for (_k = 0, _len2 = _ref64.length; _k < _len2; _k++) {
                    sub_statement = _ref64[_k];
                    _results2.push((function() {
                      var _l, _len3, _ref65, _results3;
                      _ref65 = sub_statement.nodes;
                      _results3 = [];
                      for (_l = 0, _len3 = _ref65.length; _l < _len3; _l++) {
                        sub_node = _ref65[_l];
                        _results3.push(links_by_id.push({
                          type: ltype,
                          id1: prev_node.id,
                          id2: sub_node.id,
                          label: current_attributes.edge.label
                        }));
                      }
                      return _results3;
                    })());
                  }
                  return _results2;
                })());
              } else {
                _results1.push(links_by_id.push({
                  type: ltype,
                  id1: prev_node.id,
                  id2: node.id,
                  label: current_attributes.edge.label
                }));
              }
            }
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };
  populate(graph.statements);
  elements_by_id = {};
  for (id in nodes_by_id) {
    elt = nodes_by_id[id];
    elements_by_id[id] = new elt.type(void 0, void 0, elt.label);
    diagram.elements.push(elements_by_id[id]);
  }
  for (_i = 0, _len = links_by_id.length; _i < _len; _i++) {
    lnk = links_by_id[_i];
    l = new lnk.type(elements_by_id[lnk.id1], elements_by_id[lnk.id2]);
    l.text.source = lnk.label;
    diagram.links.push(l);
  }
  d.title = attributes.graph.label || graph.id;
  d.force = true;
  return d.hash();
};

$(function() {
  if (location.pathname.match(/\/test\//)) {
    return;
  }
  list_diagrams();
  $('.dot2umlaut').click(function() {
    return location.hash = dot($(this).siblings('textarea.dot').val());
  });
  _this.addEventListener("popstate", history_pop);
  if (location.hash && (_this.mozInnerScreenX != null)) {
    return history_pop();
  }
});
